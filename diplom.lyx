#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
% Footnotes will be "numbered" by symbols (reset on each page)
\renewcommand{\thefootnote}{ \fnsymbol{footnote}}
\@addtoreset{footnote}{page}

% Yes! It allows to indent first paragraphs!
\usepackage{indentfirst}

% Allows to unite several rows in the table
\usepackage{multirow}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.5
\use_hyperref true
\pdf_bookmarks false
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Предметный указатель
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\headheight 1cm
\headsep 1cm
\footskip 0.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Введение
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Введение}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Рефакторинг – это преобразование исходного кода программы, направленное
 на улучшение читаемости кода или усовершенствование архитектуры и не изменяющее
 семантику работы программы.
 Использование рефакторинга упрощает поддержку кода и позволяет безопасно
 подготовить его к архитектурным изменениям.
 Регулярный рефакторинг кода снижает вероятность появления ошибок.
\end_layout

\begin_layout Standard
Язык Go - императивный язык программирования, разработанный компанией Google
 в 2009 г.
 Этот язык довольно быстро развивается и с каждым годом становится популярнее
 среди программистов.
 Язык Go появился совсем недавно, поэтому инструментальная база этого языка
 лишь начинает формироваться.
 Начинают появляться простейшие среды разработки, с подсветкой синтаксиса
 и упрощенным интерфейсом компиляции.
 Однако, по-порежнему разработчикам недоступны средства автодополнения кода
 и автоматизированного рефакторинга программ.
\end_layout

\begin_layout Standard
Целью данной дипломной работы является разработка системы автоматизированного
 рефакторинга GoRefactor, выполняющую эквивалентные преобразования программ,
 написанных на языке Go.
 Система должна быть самоприменима, то есть языком реализации также должен
 быть язык Go.
\end_layout

\begin_layout Standard
Структурно система GoRefactor должна состоять из двух частей: 
\end_layout

\begin_layout Enumerate
Cемантический анализатор программ, написанных на языке Go.
 Практически ни один рефакторинг не может быть проведен без семантического
 анализа, так как для проведения преобразования необходимо обладать информацией
 об областях видимости идентификаторов.
\end_layout

\begin_layout Enumerate
Модули рефакторинга.
 Работа всех модулей базируется на информации, полученной в ходе семантического
 анализа.
 Структура системы позволяет в будущем добавить в нее дополнительные модули
 рефакторига.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Обзор существующих систем рефакторинга
\begin_inset CommandInset label
LatexCommand label
name "sec:Обзор систем рефакторинга."

\end_inset


\end_layout

\begin_layout Standard
В данном разделе приведен обзор существующих разработок в области автоматическог
о рефакторинга.
 Для обзора взяты три мощные среды разработки: Microsoft Visual Studio 2010,
 Eclipse, IntelliJ IDEA 9.0.3.
 В обзоре проведено сравнение этих программных пакетов по предоставляемым
 инструментам работы с исходным кодом, а также кратко описаны некоторые
 базовые и продвинутые приемы рефакторинга.
 
\end_layout

\begin_layout Subsection
MS Visual Studio 2010
\end_layout

\begin_layout Standard
Среда разработки Microsoft Visual Studio 2010 для языка C#, содержит базовый
 набор приемов рефакторинга.
 Он включает в себя переименование идентификаторов, извлечение метода, инкапсуля
цию поля в свойства, а также извлечение и реализацию интерфейсов и изменение
 сигнатуры метода.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

переименование идентификатора
\begin_inset Quotes frd
\end_inset

 позволяет безопасно переименовывать идентификаторы сущностей программы
 (переменных, методов, имен классов и т.д.), осуществляя модификацию всех
 вхождений сущности в исходный код.
 
\end_layout

\begin_layout Standard
Извлечением метода называют выделение выбранного набора инструкций языка
 в отдельный метод и замена этих инструкций вызовом метода.
 Среда разработки самостоятельно определяет сигнатуру метода.
 
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

инкапсуляция поля в свойство
\begin_inset Quotes frd
\end_inset

 позволяет обернуть поле в свойство, с автоматическим созданием заглушек
 для методов доступа get и set.
 
\end_layout

\begin_layout Standard
Извлечение интерфейса из класса – это создание интерфейса на основе некоторых
 (или всех) public свойств или методов класса.
 
\end_layout

\begin_layout Standard
Реализация интерфейса – это создание в классе заглушек методов и свойств,
 необходимых для реализации классом выбранного интерфейса.
 
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

изменение сигнатуры метода
\begin_inset Quotes frd
\end_inset

 позволяет безопасно переставлять и удалять параметры метода, производя
 необходимые изменения во всех вызовах этого метода.
 
\end_layout

\begin_layout Standard
Продвинутые средства рефакторинга для Visual Studio подключаются в виде
 коммерчески-распространяемого плагина ReSharper.
 
\end_layout

\begin_layout Subsection
Eclipse
\end_layout

\begin_layout Standard
Среда разработки Eclipse для языка Java включает в себя все приемы рефакторинга,
 доступные в Microsoft Visual Studio 2010.
 Кроме них, разработчик может воспользоваться следующими преобразованиями:
 генерация конструктора, перемещение сущностей между классами и вдоль иерархии
 наследования, изменение сигнатуры метода, сортировка объявлений.
\end_layout

\begin_layout Standard
Изменение сигнатуры в Eclipse может быть выполнено в безопасном режиме,
 с сохранением старого метода.
 Метод с новой сигнатурой будет вызываться старым методом.
\end_layout

\begin_layout Standard
Eclipse позволяет сортировать как объявления внутри класса, так и сами классы
 в файле.
 При сортировке объявления объединяются в группы типам сущностей: типы,
 статические поля, статические инициализаторы, статические методы, поля,
 инициализаторы, конструкторы и методы.
\end_layout

\begin_layout Standard
Внутри группы объявления сортируются по алфавиту.
 После этого группы располагаются внутри класса в очередности, указанной
 пользователем в настройках.
\end_layout

\begin_layout Subsection
IntelliJ IDEA
\end_layout

\begin_layout Standard
IntelliJ IDEA предоставляет самый большой набор средств работы с кодом.
 Помимо вышеописанных видов рефакторинга, данная среда разработки позволяет
 автоматически производить более сложные рефакторинги.
\end_layout

\begin_layout Standard
«Безопасное» удаление сущности предупредит пользователя о том, что удаляемая
 сущность где-то используется и предоставит все ссылки на её вхождения.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

извлечение метода в объект
\begin_inset Quotes frd
\end_inset

 позволяет провести обертывание метода в отдельный класс и автоматическую
 замену его вызовов на вызовы вида: 
\family typewriter
\series bold
new NewClass().Method()
\series default
 
\family default
.
\end_layout

\begin_layout Standard
Также, IntelliJ IDEA позволяет упаковать возвращаемое значение метода в
 объект нового класса или в объект существующего класса, с указанием имени
 поля, содержащего возвращаемое значение.
 
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

замена наследования на делегирование
\begin_inset Quotes frd
\end_inset

 выглядит так: методы целевого интерфейса оборачиваются в новый внутренний
 класс, и в исходном классе создается объект этого класса.
 Вызовы методов интерфейса исходный класс делегирует этому объекту.
 
\end_layout

\begin_layout Standard
IntelliJ IDEA предоставляет возможность автоматического поиска фрагментов
 кода, дублирующих код определенного метода, и замену этих фрагментов вызовом
 метода.
 
\end_layout

\begin_layout Subsection
Примеры
\end_layout

\begin_layout Standard
В этом разделе приведены примеры рефакторинга кода.
\end_layout

\begin_layout Subsubsection
Изменение сигнатуры метода в Eclipse
\end_layout

\begin_layout Standard
Пусть есть следующий метод:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public int someMethod(int a){ 
\end_layout

\begin_layout Plain Layout

	return 10*a;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Если применить команду 
\begin_inset Quotes fld
\end_inset

Change Method Signature...
\begin_inset Quotes frd
\end_inset

, и в диалоговом окне добавить новый параметр типа 
\family typewriter
\series bold
Object
\family default
\series default
, а также установить флаг 
\begin_inset Quotes fld
\end_inset

Keep original method as delegate to changed method
\begin_inset Quotes frd
\end_inset

, то результат будет выглядеть следующим образом:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public int someMethod(int a){
\end_layout

\begin_layout Plain Layout

	return someMethod(a, null); 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public int someMethod(int a, Object newParam){
\end_layout

\begin_layout Plain Layout

	return a*10;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

В результате, старый интерфейс сохранился, и клиентский код, использовавший
 старый метод, по-прежнему компилируется.
 Во второй строке листинга видно, что старый метод вызывает новый с некоторым
 значением по умолчанию для нового параметра (в данном случае 
\family typewriter
\series bold
null
\family default
\series default
)
\end_layout

\begin_layout Subsubsection
Обертывание метода в класс в IntelliJ IDEA
\begin_inset CommandInset label
LatexCommand label
name "sub:Обертывание-метода-в"

\end_inset


\end_layout

\begin_layout Standard
Обертывание метода в класс представляет собой следующее преобразование.
 Пусть есть метод:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public int someMethod(){ 
\end_layout

\begin_layout Plain Layout

	return 10;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Команда «Extract Method Object…» запросит у пользователя имя и некоторые
 свойства нового класса, после чего произведет рефакторинг.
 Например, если дать новому классу имя 
\family typewriter
\series bold
NewClass
\family default
\series default
 и объявить его 
\family typewriter
\series bold
private
\family default
\series default
-классом, то преобразованный код будет выглядеть так:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public int someMethod(){ 
\end_layout

\begin_layout Plain Layout

	return new NewClass().invoke();
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private class NewClass{
\end_layout

\begin_layout Plain Layout

	public int invoke(){
\end_layout

\begin_layout Plain Layout

		return 10;
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset

Обертывание метода в класс обычно применяется для упрощения сигнатуры метода
 с слишком большим количеством параметров.
 Когда метод обернут в класс, он становится гораздо более гибким и настраиваемым
, так как может использовать поля и внутренние методы класса.
\end_layout

\begin_layout Subsubsection
Упаковка возвращаемого значения метода в IntelliJ IDEA
\end_layout

\begin_layout Standard
Произведем упаковку возвращаемого значения для метода 
\family typewriter
\series bold
someMethod
\family default
\series default
 из раздела 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Обертывание-метода-в"

\end_inset

.
 Команда 
\begin_inset Quotes fld
\end_inset

Wrap Return Value...
\begin_inset Quotes frd
\end_inset

 позволяет упаковать возвращаемое значение в объект нового класса (внутреннего
 или обособленного) и уже существующего класса.
 Для уже существующего класса надо указать поле для хранения упаковываемого
 значения.
 Например, если указать данной команде упаковать возвращаемое значение метода
 
\family typewriter
\series bold
someMethod
\family default
\series default
 в новый внутренний класс 
\family typewriter
\series bold
StoreClass
\family default
\series default
, то в результате мы получим:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public StoreClass someMethod(){ 
\end_layout

\begin_layout Plain Layout

	return new StoreClass(10);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class StoreClass{
\end_layout

\begin_layout Plain Layout

	private final int value;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public StoreClass(int value){
\end_layout

\begin_layout Plain Layout

		this.value = value;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	public int getValue(){
\end_layout

\begin_layout Plain Layout

		return value;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset

Как мы видим, этот рефакторинг позволяет быстро изменить тип возвращаемого
 значения метода.
 Это может применяться для унификации типов возвращаемых значений некоторого
 набора методов.
\end_layout

\begin_layout Subsubsection
Замена наследования на делегирование в IntelliJ IDEA
\end_layout

\begin_layout Standard
Пусть есть некоторый интерфейс 
\family typewriter
\series bold
SomeInterface
\family default
\series default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public interface SomeInterface{ 
\end_layout

\begin_layout Plain Layout

	int someMethod(int x);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
И есть класс 
\family typewriter
\series bold
SomeClass
\family default
\series default
, который реализует этот интерфейс: 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public class SomeClass implements SomeInterface{ 
\end_layout

\begin_layout Plain Layout

	int someMethod(int x){
\end_layout

\begin_layout Plain Layout

		return x;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Если применить команду 
\begin_inset Quotes fld
\end_inset

Replace Inheritance With Delegation...
\begin_inset Quotes frd
\end_inset

, то класс изменится следующим образом:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=Java,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

public class SomeClass{
\end_layout

\begin_layout Plain Layout

	private final InnerSomeInterfaceClass someInterface =
\end_layout

\begin_layout Plain Layout

							new InnerSomeInterfaceClass();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public int someMethod(int x){  
\end_layout

\begin_layout Plain Layout

		return someInterface.someMethod(x); 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private class InnerSomeInterfaceClass 
\end_layout

\begin_layout Plain Layout

				  implements SomeInterface{
\end_layout

\begin_layout Plain Layout

		public int someMethod(int x){
\end_layout

\begin_layout Plain Layout

			return x;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Здесь закрытое поле 
\family typewriter
\series bold
someInterface
\family default
\series default
 -- это делегат, которому перенаправляются все вызовы методов интерфейса
 
\family typewriter
\series bold
SomeInterface
\family default
\series default
.
 Тип этого делегата -- автоматически созданный внутренний класс 
\family typewriter
\series bold
InnerSomeInterfaceClass
\family default
\series default
, в котором теперь хранится реализация всех методов интерфейса 
\family typewriter
\series bold
SomeInterface
\family default
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Основные сведения о языке Go
\begin_inset CommandInset label
LatexCommand label
name "sec:Основные-сведения"

\end_inset


\end_layout

\begin_layout Standard
В этом разделе кратко описан синтаксис языка программирования Go.
 Также описаны основные особенности этого языка и их значение в контексте
 семантического анализа и рефакторинга программ.
\end_layout

\begin_layout Subsection
Структура программ и синтаксис
\begin_inset CommandInset label
LatexCommand label
name "sub:Структура-и-синтаксис"

\end_inset


\end_layout

\begin_layout Standard
Программой на языке Go является набор так называемых пакетов (package).
 Любой пакет имеет определенное имя и состоит из одного или нескольких файлов
 с исходным кодом.
 Любая сущность, объявленная в файле пакета, видна в других файлах этого
 пакета.
 Если имя сущности начинается с заглавной буквы, -- она экспортируется,
 то есть может быть  использована в других пакетах.
\end_layout

\begin_layout Standard
Импортировать пакет можно с помощью оператора 
\family typewriter
\series bold
import
\family default
\series default
.
 Для импортируемого пакета можно указать специальный псевдоним, отличный
 от имени пакета, под которым к нему можно будет обращаться в пределах этого
 файла.
\end_layout

\begin_layout Standard
Язык Go позволяет объявлять и использовать несколько видов сущностей.
 Это переменные и константы, пользователькие именованные типы данных, а
 также функции и методы.
\end_layout

\begin_layout Standard
Пользовательские типы могут быть созданы на основе базовых типов данных
 Go: структур, массивов, срезов, отображений, каналов, интерфейсов, типов-функци
й.
\end_layout

\begin_layout Standard
Методом в Go называется функция, вызываемая для экземпляров определенного
 типа.
 Здесь можно провести аналогию с методами класса в объектно-ориентированных
 языках программирования.
\end_layout

\begin_layout Standard
Язык Go имеет ряд синтаксический особенностей, которые описаны ниже.
\end_layout

\begin_layout Standard
Наряду со стандартным объявлением переменной с явным указанием типа, в Go
 есть возможность совместить объявление переменной с одновременным присваиванием
 ей значения.
 Это действие называется объявлением переменной с выведением типа и записывается
 как обычное присваивание, где вместо оператора присваивания '
\family typewriter
\series bold
=
\family default
\series default
' используется специальный оператор '
\family typewriter
\series bold
:=
\family default
\series default
'.
 В этом случае компилятор самостоятельно вычисляет тип переменной по типу
 присваиваемого значения.
\end_layout

\begin_layout Standard
Наличие такого оператора означает, что семантический анализатор должен уметь
 вычислять тип произвольного выражения языка.
\end_layout

\begin_layout Standard
Также в Go существует специальная конструкция для удобного объявления набора
 связанных констант.
 Переменные и константы в Go могут быть объявлены целыми блоками.
 Например, блок, в котором объявляются три константы A, B и C, выглядит
 как
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

const (
\end_layout

\begin_layout Plain Layout

	A = 0
\end_layout

\begin_layout Plain Layout

	B = 1
\end_layout

\begin_layout Plain Layout

	C = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset

Для удобства, в блоках констант может быть использовать идентификатор 
\family typewriter
\series bold
iota
\family default
\series default
, значение которого в начале блока равно 0 и инкрементируется на каждом
 вхождении идентификатора iota в блоке.
\end_layout

\begin_layout Standard
Если при объявлении константы используется iota, то ее значение зависит
 от положения объявления внутри блока.
 Тем самым, рефакторинг не должен изменять порядок объявлений таких констант
 внутри блока, и, например, их сортировка оказывается невозможной.
\end_layout

\begin_layout Standard
Язык Go позволяет выполнять мультиприсваивание.
 Операторы присваивания и быстрого объявления могут принимать сразу по несколько
 операндов слева и справа.
 Например, корректна следующая запись:
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

a,b = 1,2
\end_layout

\end_inset

Кроме того, функции и методы также могут возвращать целый список значений,
 и в правой части присваивания вместо списка операндов может стоять вызов
 такой функции:
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

a,b = getAandB()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Также, в Go есть возможность замены списка аргументов в вызове функции вызовом
 другой функции.
 Пусть объявлены функции 
\family typewriter
\series bold
f
\family default
\series default
 и 
\family typewriter
\series bold
g
\family default
\series default
:
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f(a int,b string){}
\end_layout

\begin_layout Plain Layout

func g() (int,string){}
\end_layout

\end_inset

Тогда, композиция этих функций может быть записана вот так:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

f(g())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Возможности мультиприсваивания и замены списка аргументов вызовом означают,
 что рефакторинг функций и методов Go должен уметь работать со списками
 возвращаемых значений.
 Например, должно быть возможно извлечение списка выражений в метод.
\end_layout

\begin_layout Subsection
Типизация
\begin_inset CommandInset label
LatexCommand label
name "sub:Типизация"

\end_inset


\end_layout

\begin_layout Standard
Язык Go не является объектно-ориентированным языком, в нем нет таких понятий
 как 
\begin_inset Quotes fld
\end_inset

класс
\begin_inset Quotes frd
\end_inset

 и 
\begin_inset Quotes fld
\end_inset

наследование
\begin_inset Quotes frd
\end_inset

.
 С другой стороны, с любым именованным типом может быть связан набор методов,
 вызов которых для значения этого типа можно понимать как передачу объекту
 сообщения.
 Также есть механизм встраивания типов, напоминающий наследование.
\end_layout

\begin_layout Standard
В языке Go реализована статическая 
\begin_inset Quotes fld
\end_inset

утиная
\begin_inset Quotes frd
\end_inset

 типизация.
 Это означает, что можно объявить некоторый тип-интерфейс I, представляющий
 собой набор заголовков методов, и тогда значение типа T автоматически становитс
я совместимо по присваиванию с переменной типа I, если тип T обладает указанным
 в объявлении интерфейса I набором методов.
 Ключевое отличие типов-интерфейсов языка Go от интерфейсов в других языках
 заключается в том, что типы языка Go реализуют интерфейсы неявно, по факту
 обладания нужным набором методов, тогда как другие строго типизированные
 объектно-ориентированные языки (например, Java) требуют явного указания
 реализуемых интерфейсов при объявлении типа.
 Это, с одной стороны, роднит язык Go с такими языками, как Python и Ruby,
 обладающими 
\begin_inset Quotes fld
\end_inset

утиной
\begin_inset Quotes frd
\end_inset

 типизацией в силу своей динамической природы (проверка существования метода
 у значения осуществляется во время выполнения программы при попытке вызова
 этого метода).
 С другой стороны, в отличие от динамических языков, совместимость значений
 с интерфейсами проверяется компилятором языка Go статически, а не во время
 выполнения программы.
 Приведем пример, демонстрирующий статическую утиную типизацию в языке Go:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

type Reader interface {
\end_layout

\begin_layout Plain Layout

    Read(p []byte) (n int, err os.Error) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type T1 int
\end_layout

\begin_layout Plain Layout

type T2 int
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func (t T1) Read(p []byte) (n int, err os.Error) {
\end_layout

\begin_layout Plain Layout

	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
В этом случает тип 
\family typewriter
\series bold
T1
\family default
\series default
 реализует интерфейс 
\family typewriter
\series bold
Reader
\family default
\series default
, хотя явным образом это нигде не указывается.
 Если есть некая функция 
\family typewriter
\series bold
f
\family default
\series default
, принимающая на вход значение типа 
\family typewriter
\series bold
Reader
\family default
\series default
, то при передаче в нее значения типа 
\family typewriter
\series bold
T2
\family default
\series default
 компилятор выдаст ошибку, в то время как передача  в функцию 
\family typewriter
\series bold
f
\family default
\series default
 значения типа 
\family typewriter
\series bold
T1
\family default
\series default
, напротив, является корректным действием.
\end_layout

\begin_layout Standard
В языке Go нет понятия наследования в полном смысле этого слова.
 Механизм встраивания (embedding) позволяет одному типу расширить функциональнос
ть одного или сразу нескольких типов.
\end_layout

\begin_layout Standard
Встраивание типа 
\family typewriter
\series bold
T1
\family default
\series default
 в 
\family typewriter
\series bold
T2
\family default
\series default
 выглядит так:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

type T1 struct {
\end_layout

\begin_layout Plain Layout

    A int
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

func (t T1) F() {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type T2 struct{
\end_layout

\begin_layout Plain Layout

	T1
\end_layout

\begin_layout Plain Layout

	B int
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Тип 
\family typewriter
\series bold
T2
\family default
\series default
 называется расширяющим типом.
 Его набор методов 
\begin_inset Quotes fld
\end_inset

унаследует
\begin_inset Quotes frd
\end_inset

 метод 
\family typewriter
\series bold
F
\family default
\series default
 от типа 
\family typewriter
\series bold
T1
\family default
\series default
.
 Кроме того, имея значение 
\family typewriter
\series bold
x
\family default
\series default
 типа 
\family typewriter
\series bold
T2
\family default
\series default
, можно обращаться к полю 
\family typewriter
\series bold
A
\family default
\series default
 значения 
\family typewriter
\series bold
x
\family default
\series default
 напрямую, то есть выражение 
\family typewriter
\series bold
x.T1.A
\family default
\series default
 можно записывать просто как 
\family typewriter
\series bold
x.A
\family default
\series default
.
\end_layout

\begin_layout Subsection
Средства распараллеливания и синхронизации параллельных вычислений
\end_layout

\begin_layout Standard
Одним из главных достоинств языка Go является наличие мощных и удобных встроенны
х средств распараллеливания и синхронизации параллельных вычислений.
 
\end_layout

\begin_layout Standard
Go-рутиной называется функция языка Go, выполняющаяся параллельно основному
 потоку и другим Go-рутинам.
 Go-рутина может быть создана в любом места программы с помощью специального
 оператора 
\family typewriter
\series bold
go
\family default
\series default
.
 После завершения функции Go-рутина уничтожается.
\end_layout

\begin_layout Standard
Go-рутины синхронизируются с помощью каналов.
 Каналом называется специальный объект, через который Go-рутины могут обменивать
ся другими объектами.
 Например, одна Go-рутина может 
\begin_inset Quotes fld
\end_inset

послать
\begin_inset Quotes frd
\end_inset

 значение в канал, а другая получить его из канала.
 Операции посылки/приема могут быть как блокирующими, так и неблокирующими.
 В случае блокирующего приема Go-рутина останавливает свое выполнение, пока
 какой-нибудь другой код не пошлет что-нибудь в этот канал.
 Соответственно блокирующая посылка остановит Go-рутину до того момента,
 пока не найдется получатель.
\end_layout

\begin_layout Standard
Неблокирующая операция посылки/приема не останавливает выполнение Go-рутины.
 В случае отсутствия объекта на другом конце канала, операция возвращает
 нулевое значение соответствующего типа и специальный флаг, сообщающий о
 неуспешной операции.
 Для неблокирующих операций каналы могут иметь буфер конечного размера.
\end_layout

\begin_layout Standard
Классические синхрообъекты (например, мьютексы) доступны в стандартной библиотек
е пакетов языка Go.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Семантика выполняемых преобразований
\begin_inset CommandInset label
LatexCommand label
name "sec:Семантика-преобразований"

\end_inset


\end_layout

\begin_layout Standard
В этой главе описаны методы рефакторинга, реализованные в данной дипломной
 работе.
 Также разобраны особенности проведения этих преобразований в программах,
 написанных на Go.
\end_layout

\begin_layout Subsection
Переименование идентификаторов
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

переименование идентификатора
\begin_inset Quotes frd
\end_inset

 позволяет безопасно переименовать все вхождения выбранной сущности программы.
 
\end_layout

\begin_layout Standard
Это преобразование применяется для улучшения читаемости программы.
 Человек, работающий с кодом, в случае хорошо подобранного названия гораздо
 быстрее поймет назначение сущности.
 Если это назначение меняется, или принято решение о присвоении сущности
 более подходящего имени, применяется рефакторинг 
\begin_inset Quotes fld
\end_inset

переименование идентификатора
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
Черты языка Go вносят некоторые особенности в семантику этого преобразования.
 Наиболее существенное ограничение при переименовании сущности -- влияние
 имени на модификатор доступа к сущности.
 
\end_layout

\begin_layout Standard
В языке Go есть всего два модификатора доступа: 
\begin_inset Quotes fld
\end_inset

внутренний
\begin_inset Quotes frd
\end_inset

 и 
\begin_inset Quotes fld
\end_inset

экспортируемый
\begin_inset Quotes frd
\end_inset

.
 Сущности первого типа видны лишь в пределах пакета, в котором они объявлены.
 К экспортируемым сущностям можно получить доступ и из других пакетов.
 Если первая буква имени сущности является заглавной, то сущность экспортируется.
 Если же имя начинается со строчной буквы -- сущность является внутренней.
 
\end_layout

\begin_layout Standard
В контексте рефакторинга это правило означает, что при переименовании недопустим
о менять регистр первой буквы имени.
 В противном случае, это, очевидно, приведет к изменению семантики программы,
 что противоречит определению рефакторинга.
\end_layout

\begin_layout Standard
Есть определенный класс символов, переименование которых также связано с
 некоторыми особенностями языка Go.
 В этом языке есть специальная конструкция, позволяющая производить передачу
 управления в зависимости от типа определенного выражения.
 Ниже приведен пример такой конструкции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

switch t := s.(type){
\end_layout

\begin_layout Plain Layout

	case int: //...
\end_layout

\begin_layout Plain Layout

	case bool: //...
\end_layout

\begin_layout Plain Layout

	case io.Reader: //...
\end_layout

\begin_layout Plain Layout

	case os.Error: //...	
\end_layout

\begin_layout Plain Layout

	default:	//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Здесь в блоке 
\family typewriter
\series bold
default
\family default
\series default
 переменная 
\family typewriter
\series bold
t
\family default
\series default
 имеет тот же тип, что и переменная 
\family typewriter
\series bold
s
\family default
\series default
, а в каждом 
\family typewriter
\series bold
case
\family default
\series default
-блоке -- тип, указанный после соответствующего слова 
\family typewriter
\series bold
case
\family default
\series default
.
 То есть, с одной стороны, мы имеем один символ 
\family typewriter
\series bold
t
\family default
\series default
, с другой стороны, в зависимости от области использования, этот символ
 имеет разный тип.
 В контексте переименования это означает, что несмотря на множественность
 типов переменной 
\family typewriter
\series bold
t
\family default
\series default
, представление программы, созданное семантическим анализатором, должно
 позволять прозрачное переименование всех вхождений переменной 
\family typewriter
\series bold
t
\family default
\series default
 во все 
\family typewriter
\series bold
case
\family default
\series default
/
\family typewriter
\series bold
default
\family default
\series default
-блоки.
\end_layout

\begin_layout Subsection
Извлечение метода
\end_layout

\begin_layout Standard
Извлечение метода -- прием рефакторинга, производящий выделение выбранного
 набора инструкций языка в отдельный метод и замену этих инструкций вызовом
 метода.
 Извлечение метода применяется для устранения дублирования кода, разбиения
 слишком больших методов на части и улучшения читаемости кода.
 Ниже приведены несколько примеров, демонстрирующие наиболее частые случаи
 применения рефакторинга 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
Разработчику часто бывает необходимо устранить дублирование кода.
 Это делается с помощью выделения повторяющейся логики в отдельный метод.
 Пусть есть две функции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f1(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	a.m1(b)
\end_layout

\begin_layout Plain Layout

	c.m2(a)
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func f2(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	a1.m1(b1)
\end_layout

\begin_layout Plain Layout

	c1.m2(a1)
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

В обеих функциях выделенные участки кода выполняют идентичные действия с
 локальными переменными.
 Эти участки лучше заменить вызовом новой функции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func newF(a Ta,b Tb,c Tc){
\end_layout

\begin_layout Plain Layout

	a.m1(b)
\end_layout

\begin_layout Plain Layout

	c.m2(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func f1(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	newF(a,b,c)
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func f2(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	newF(a1,b1,c1)
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Выделение выбранного набора инструкций функции 
\family typewriter
\series bold
f1
\family default
\series default
 в функцию 
\family typewriter
\series bold
newF
\family default
\series default
 и замена этого набора на вызов и называется извлечением метода.
 Такой прием может использоваться даже при отсутствии дублирования, в случае,
 когда нужно разбить слишком длинный метод на логические части.
\end_layout

\begin_layout Standard
В данном примере дублирующий фрагмент кода функции 
\family typewriter
\series bold
f2
\family default
\series default
 также заменен на вызов, но эта операция не входит в обязанности рефакторинга
 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

 и должна быть выполнена программистом вручную.
 Поиск фрагментов кода с идентичной семантикой -- это отдельная задача.
 В современных системах рефакторинга начинает появляться подобный функционал,
 однако, качество результатов оставляет желать лучшего.
\end_layout

\begin_layout Standard
Также извлечение метода применяется для улучшения читаемости сложных выражений.
 Приведем пример:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if (p<745 && l>0.98 && cloudsColor == black) {
\end_layout

\begin_layout Plain Layout

	doSomething() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Здесь с первого взгляда сложно понять, в чем заключается смысл условия в
 операторе 
\family typewriter
\series bold
if
\family default
\series default
.
 Однако, выделение этого выражения в метод позволяет дать ему описание:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if isItRaining(p, l, cloudsColor) {
\end_layout

\begin_layout Plain Layout

	doSomething() 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

func isItRaining(p,l double,cloudsColor Color) bool {
\end_layout

\begin_layout Plain Layout

	return (p<745 && l>0.98 && cloudsColor == black) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Теперь смысл ветвления стал гораздо более прозрачным, и код читается лучше.
\end_layout

\begin_layout Standard
Так как функция в языке Go может возвращать список из нескольких объектов,
 то рефакторинг 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

 для программ на Go должен уметь извлекать в метод произвольный список выражений.
\end_layout

\begin_layout Standard
Наличие в Go указателей и оператора взятия адреса позволяет извлекать в
 метод код, содержащий присваивание переменной, являющейся для нового метода
 параметром.
 Рассмотрим пример:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f1(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	a = 10
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Простой перенос оператора присваивания в новую функцию нарушит семантику
 работы программы, потому что после вызова значение переменной 
\family typewriter
\series bold
a
\family default
\series default
 в функции 
\family typewriter
\series bold
f1
\family default
\series default
 останется тем же, что и до вызова.
 Передача параметра по указателю позволяет решить эту проблему:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f1(){
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

	newF(&a)
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

func newF(a *int){
\end_layout

\begin_layout Plain Layout

	*a = 10
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Здесь функции 
\family typewriter
\series bold
f1
\family default
\series default
 и 
\family typewriter
\series bold
newF
\family default
\series default
 работают с одной и той же ячейкой памяти, поэтому изменения, проведенные
 функцией 
\family typewriter
\series bold
newF
\family default
\series default
 будут видны функции 
\family typewriter
\series bold
f1
\family default
\series default
.
\end_layout

\begin_layout Subsection
Встраивание метода
\begin_inset CommandInset label
LatexCommand label
name "sub:Встраивание-метода"

\end_inset


\end_layout

\begin_layout Standard
Встраивание метода -- прием рефакторинга, который заменяет вызов метода
 его кодом с подстановкой передаваемых параметров.
 Операция встраивания метода является обратной к операции извлечения метода.
 Она применяется в случаях, когда в определенном месте программы поведение,
 заданное вызываемым методом, нужно поменять.
 Также встраивание метода может понадобиться, когда в процессе разработки
 остался лишь один вызов некоторого метода, и этот вызов можно встроить
 без вреда для читаемости кода.
\end_layout

\begin_layout Standard
Одной из проблем, которые необходимо решить при реализации встраивания метода
 -- конфликты имен локальных переменных метода с именами переменных, видимых
 в области, в которой находится встраиваемый вызов.
 
\end_layout

\begin_layout Standard
Далее приведен пример встраивания метода.
 Этот пример демонстрирует одну из проблем, возникающих при страивании метода.
 Пусть объявлена функция 
\family typewriter
\series bold
f1
\family default
\series default
 и функция 
\family typewriter
\series bold
f2
\family default
\series default
, которая вызывает 
\family typewriter
\series bold
f1
\family default
\series default
.
 Задачей в данном примере является встраивание вызова фунции 
\family typewriter
\series bold
f1
\family default
\series default
 в функцию 
\family typewriter
\series bold
f2
\family default
\series default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f1(a int){
\end_layout

\begin_layout Plain Layout

	b := false
\end_layout

\begin_layout Plain Layout

	println(a, b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

func f2(){
\end_layout

\begin_layout Plain Layout

	b:= true
\end_layout

\begin_layout Plain Layout

	f1(5)
\end_layout

\begin_layout Plain Layout

	println(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Как мы видим, в коде обеих функций объявлены локальные переменные с именем
 
\family typewriter
\series bold
b
\family default
\series default
.
 Это не позволяет при проведении встраивания просто перенести код в функцию
 
\family typewriter
\series bold
f2
\family default
\series default
, поэтому встраивание в этом случае подразумевает также переименование локальной
 переменной 
\family typewriter
\series bold
b
\family default
\series default
 во встраиваемом коде.
 Так она не будет конфликтовать с локальной переменной 
\family typewriter
\series bold
b
\family default
\series default
 функции 
\family typewriter
\series bold
f2
\family default
\series default
.
 Код функции 
\family typewriter
\series bold
f2
\family default
\series default
 после преобразования приведен ниже:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f2(){
\end_layout

\begin_layout Plain Layout

	b:= true
\end_layout

\begin_layout Plain Layout

	b0 := false
\end_layout

\begin_layout Plain Layout

	println(5, b0)
\end_layout

\begin_layout Plain Layout

	println(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Отметим также, что вместо параметра 
\family typewriter
\series bold
a
\family default
\series default
 было подставлено выражение, переданное в вызов.
 Подстановка параметров также входит в задачи процедуры встраивания метода.
\end_layout

\begin_layout Subsection
Извлечение интерфейса
\begin_inset CommandInset label
LatexCommand label
name "sub:Извлечение-интерфейса"

\end_inset


\end_layout

\begin_layout Standard
Классическое преобразование извлечения интерфейса в объектно-ориентированных
 языках программирования определяется как создание интерфейса, включающего
 в себя все публичные методы некоторого класса.
 Однако, в языке с утиной типизацией, коим является Go, такая операция не
 принесет большой пользы.
 
\end_layout

\begin_layout Standard
Гораздо более практичной является следующая вариация извлечения интерфейса:
 формирование нового интерфейса из всех обращений к параметру некоторого
 метода в рамках этого метода.
 После создания интерфейса тип параметра заменяется на этот интерфейс.
 Такая операция перехода от конкретного типа к интерфейсному позволяет обобщить
 метод на целый класс параметров, не затрагивая при этом семантику существующего
 кода.
\end_layout

\begin_layout Standard
Приведем пример извлечения интерфейса.
 Исходный метод вычисляет средний цвет по всем пикселам JPG-изображения,
 которое передается как аргумент:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func color(i JPGImage) int {
\end_layout

\begin_layout Plain Layout

	n,c := i.PixelCount(),0
\end_layout

\begin_layout Plain Layout

	for k:=0; k < n; k++{
\end_layout

\begin_layout Plain Layout

		c += i.Pixel(k)
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return int(c/n) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Проведем извлечение интерфейса для параметра 
\family typewriter
\series bold
i
\family default
\series default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func color(i IImage) int {
\end_layout

\begin_layout Plain Layout

	//...
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

type IImage interface {
\end_layout

\begin_layout Plain Layout

	PixelCount() int
\end_layout

\begin_layout Plain Layout

	Pixel(int) int 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Проведя извлечение интерфейса, мы обобщили функцию 
\family typewriter
\series bold
color
\family default
\series default
 на все множество изображений, то есть теперь функция 
\family typewriter
\series bold
color
\family default
\series default
 может работать не только с JPG изображениями, а со всеми объектами, реализующим
и интерфейс 
\family typewriter
\series bold
IImage
\family default
\series default
.
 
\end_layout

\begin_layout Standard
Стоит заметить, что при извлечении интерфейса необходимо проверить, что
 с параметром, для которого извлекается интерфейс, не производится никаких
 действий, кроме вызова его методов и еще небольшого набора разрешенных
 действий.
 В этот набор входит сравнение с 
\family typewriter
\series bold
nil
\family default
\series default
, а также передача параметра в рекурсивный вызов на том же месте в списке
 аргументов.
 Любое другое использование этого параметра, при изменении его типа на интерфейс
ный, может привести к нарушению семантики работы программы или даже к ошибкам
 компиляции.
\end_layout

\begin_layout Subsection
Реализация интерфейса
\end_layout

\begin_layout Standard
Реализация интерфейса -- прием рефакторинга, который создает для заданного
 типа заглушки методов, реализующие заданный интерфейс.
 Это преобразование используется только как вспомогательный инструмент разработч
ика.
 
\end_layout

\begin_layout Standard
Пусть в процессе разработки вводится новый тип, который должен реализовывать
 некоторый насыщенный методами интерфейс.
 Тогда автоматическая реализация интерфейса позволяет программисту не тратить
 время на рутинное кодирование сигнатур методов.
 Код методов, созданных этим рефакторингом должен генерировать исключение,
 сообщающее разработчику о том, что логика метода еще не реализована.
\end_layout

\begin_layout Standard
Приведем пример проведения реализации интерфейса.
 Пусть есть интерфейс 
\family typewriter
\series bold
ICar
\family default
\series default
, и разработчик добавляет тип 
\family typewriter
\series bold
Kalina
\family default
\series default
, который должен реализовывать этот интерфейс:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

type ICar interface{
\end_layout

\begin_layout Plain Layout

	Start()
\end_layout

\begin_layout Plain Layout

	Go(km int)
\end_layout

\begin_layout Plain Layout

	Stop()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

type Kalina int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Проведение процедуры реализации интерфейса 
\family typewriter
\series bold
ICar
\family default
\series default
 для типа 
\family typewriter
\series bold
Kalina
\family default
\series default
, дополнит код следующими методами:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func (Kalina) Start() {
\end_layout

\begin_layout Plain Layout

	panic("Not Implemented")
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

func (Kalina) Go(km int) {
\end_layout

\begin_layout Plain Layout

	panic("Not Implemented")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

func (Kalina) Stop() {
\end_layout

\begin_layout Plain Layout

	panic("Not Implemented") 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Мы видим, что теперь разработчик может сразу приступить к реализации логики
 методов, не тратя время на кодирование сигнатур.
\end_layout

\begin_layout Standard
У рефакторинга 
\begin_inset Quotes fld
\end_inset

реализация интерфейса
\begin_inset Quotes frd
\end_inset

 есть свои подводные камни.
 Например, тип может уже частично реализовывать выбранный интерфейс.
 В этом случае, процедура должна объявить лишь недостающие методы.
 Возможна и другая ситуация, когда у типа имеется метод, имя которого совпадает
 с именем одного из методов интерфейса, однако их сигнатуры различаются.
 В этом случае рефакторинг проводиться не должен, а пользователя необходимо
 проинформировать об ошибке.
\end_layout

\begin_layout Subsection
Сортировка объявлений
\end_layout

\begin_layout Standard
Сортировку объявлений обычно не относят к приемам рефакторинга, однако это
 преобразование является полезным инструментом разработчика наряду с описанными
 выше.
 Сортировка преследует те же цели, что и рефакторинг, а именно -- повышает
 читаемость кода, не изменяя семантики его работы.
 
\end_layout

\begin_layout Standard
Очевидно, что сортировка объявлений возможна лишь в языках, допускающих
 произвольный порядок объявлений.
 Язык Go относится к таким языкам.
\end_layout

\begin_layout Standard
Сортировка объявлений является очевидным преобразованием и не нуждается
 в примере.
 Однако, некоторые особенности языка Go накладывают ограничения на сортировку
 внутри групп констант.
 Эта проблема подробнее описана в разделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Структура-и-синтаксис"

\end_inset

.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Работа с исходными текстами программ на Go с помощью стандартных библиотек
\begin_inset CommandInset label
LatexCommand label
name "sec:Работа-с-исходными"

\end_inset


\end_layout

\begin_layout Standard
В разработке данной дипломной работы были использованы пакеты из стандартной
 библиотеки Go.
 В этой главе будет дано их краткое описание.
\end_layout

\begin_layout Standard
Полную документацию по используемым пакетам, а также их исходный код можно
 найти в 
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"

\end_inset

.
\end_layout

\begin_layout Subsection
Синтаксический анализ
\end_layout

\begin_layout Standard
В стандартной библиотеке пакетов языка Go есть лексический и синтаксический
 анализаторы, которые регулярно синхронизируются с частыми изменениями в
 языке.
 Поэтому было принято решение реализовать front-end
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

 системы с помощью этих пакетов.
\end_layout

\begin_layout Subsubsection
Пакет 
\begin_inset Quotes fld
\end_inset

go/parser
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Синтаксический анализатор программ на языке Go реализован в пакете 
\begin_inset Quotes fld
\end_inset

go/parser
\begin_inset Quotes frd
\end_inset

.
 Интерфейс пакета предоставляет несколько вариаций выполнения процедуры
 синтаксического разбора.
 Например, можно провести анализ одного файла или целой директории.
 В последнем случае можно указать фильтр по которому будут отбираться файлы
 для анализа.
 
\end_layout

\begin_layout Standard
При вызове любой функции синтаксического анализа из пакета 
\begin_inset Quotes fld
\end_inset

go/parser
\begin_inset Quotes frd
\end_inset

, она автоматически производит чтение входного потока и лексический анализ.
 После этого запускается синтаксический анализатор, реализованный методом
 рекурсивного спуска.
 Результатом работы функции является синтаксическое дерево или, в случае
 нескольких входных файлов, синтаксический лес.
\end_layout

\begin_layout Standard
Если текст программы содержит синтаксические ошибки, то синтаксическое дерево
 будет частично состоять из специальных узлов, обозначающих ошибку синтаксическо
го разбора.
\end_layout

\begin_layout Subsubsection
Пакет 
\begin_inset Quotes fld
\end_inset

go/ast
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Типы всех узлов синтаксического дерева, возвращаемого синтаксическим анализаторо
м, а также вспомогательный функционал для работы с такими деревьями находится
 в пакете 
\begin_inset Quotes fld
\end_inset

go/ast
\begin_inset Quotes frd
\end_inset

.
 В пакете объявлены несколько интерфейсов, соответствующих разным типам
 узлов синтаксического дерева :
\end_layout

\begin_layout Standard
Интерфейс 
\family typewriter
\series bold
ast.Node
\family default
\series default
 реализует любой узел дерева синтаксического разбора; Синтасическое дерево
 частично хранит информацию о координатах узлов в файле, поэтому каждый
 узел должен реализовывать функции 
\family typewriter
\series bold
Pos()
\family default
\series default
 и 
\family typewriter
\series bold
End()
\family default
\series default
, некоторым образом определяющие смещения границ узла относительно начала
 файла.
 Подробнее о координатной системе в разделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Пакет-go/token"

\end_inset

.
\end_layout

\begin_layout Standard
Интерфейс 
\family typewriter
\series bold
ast.Expr
\family default
\series default
 реализуется узлами-
\emph on
выражениями
\emph default
, такими как различные идентификаторы (тип 
\family typewriter
\series bold
ast.Ident
\family default
\series default
), вызовы (тип 
\family typewriter
\series bold
ast.CallExpr
\family default
\series default
), унарные и бинарные выражения (типы 
\family typewriter
\series bold
ast.UnaryExpr
\family default
\series default
 и 
\family typewriter
\series bold
ast.BinaryExpr
\family default
\series default
) и т.д.
\end_layout

\begin_layout Standard
Узлы-
\emph on
операторы
\family typewriter
\emph default
 
\family default
реализуют интерфейс 
\family typewriter
\series bold
ast.Stmt
\family default
\series default
.
 Примерами узлов-операторов являются оператор присваивания (тип 
\family typewriter
\series bold
ast.AssignStmt
\family default
\series default
), операторы ветвления (
\family typewriter
\series bold
ast.IfStmt
\family default
\series default
, 
\family typewriter
\series bold
ast.SwicthStmt
\series default
 
\family default
и т.д.) и циклов (
\family typewriter
\series bold
ast.ForStmt
\family default
\series default
, 
\family typewriter
\series bold
ast.RangeStmt
\series default
 
\family default
и т.д.).
 Также есть тип, описывающий оператор-выражение (
\family typewriter
\series bold
ast.ExprStmt
\family default
\series default
).
 Примером такого выражения может служить вызов функции, не сохраняющий результат
 возврата.
\end_layout

\begin_layout Standard
Интерфейсы
\family typewriter
\series bold
 ast.Decl
\family default
\series default
 и 
\family typewriter
\series bold
ast.Spec
\family default
\series default
 реализуются узлами-
\emph on
объявлениями
\emph default
, такими как, например, 
\family typewriter
\series bold
ast.FuncDecl
\family default
\series default
, описывающий обьявление функции, или 
\family typewriter
\series bold
ast.ValueSpec
\family default
\series default
, соответствующий обьявлению переменной.
\end_layout

\begin_layout Standard
Пакет 
\begin_inset Quotes fld
\end_inset

go/ast
\begin_inset Quotes frd
\end_inset

 предоставляет удобное средство обхода синтаксического дерева -- это функция
 
\family typewriter
\series bold
ast.Walk()
\family default
\series default
.
 Она принимает на вход объект, реализующий интерфейс 
\family typewriter
\series bold
ast.Visitor
\family default
\series default
.
 Этот интерфейс состоит из одной функции 
\family typewriter
\series bold
Visit()
\family default
\series default
, определяющей действия, которые нужно выполнить во всех узлах дерева.
\end_layout

\begin_layout Subsection
Преобразование синтаксического дерева в исходный код
\end_layout

\begin_layout Standard
Выполнение любого рефакторинга в разработанной системе подразумевает некоторое
 изменение синтаксического дерева или деревьев.
 Наряду с синтаксическим анализатором, стандартная библиотека пакетов Go
 предоставляет относительно удобное средство преобразования синтаксического
 дерева в исходный код.
 В связи с этим, было принято решение сохранять измененный код с помощью
 этого преобразования.
\end_layout

\begin_layout Standard
Пакетом, реализующим описанные функции, является пакет 
\begin_inset Quotes fld
\end_inset

go/printer
\begin_inset Quotes frd
\end_inset

.
 Далее, для простоты, он будет называться принтером, а само преобразование
 мы будем называть 
\begin_inset Quotes fld
\end_inset

печатью синтаксического дерева
\begin_inset Quotes frd
\end_inset

.
 
\end_layout

\begin_layout Standard
Для печати синтаксического дерева также используются типы из пакета 
\begin_inset Quotes fld
\end_inset

go/token
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Пакет 
\begin_inset Quotes fld
\end_inset

go/token
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Пакет-go/token"

\end_inset


\end_layout

\begin_layout Standard
Волей разработчиков из Google, пакет 
\begin_inset Quotes fld
\end_inset

go/token
\begin_inset Quotes frd
\end_inset

 несет две несвязанных функции.
 Во-первых, в нем хранится список лексем, порождаемых лексическим анализатором
 и используемых в синтаксическом дереве.
 Во-вторых, в процессе развития синтаксического анализатора, на пакет 
\begin_inset Quotes fld
\end_inset

go/token
\begin_inset Quotes frd
\end_inset

 были возложены обязанности по хранению информации о координатах узлов синтаксич
еского дерева в файле.
 На данный момент система представления этой информации состоит из трех
 элементов:
\end_layout

\begin_layout Enumerate
Целочисленные смещения начала и конца каждого узла синтаксического дерева
 относительно некоторого базового значения хранятся в самом узле.
 Они доступны с помощью функций 
\family typewriter
\series bold
Pos()
\family default
\series default
 и 
\family typewriter
\series bold
End()
\family default
\series default
 интерфейса 
\family typewriter
\series bold
ast.Node
\family default
\series default
.
\end_layout

\begin_layout Enumerate
Объект типа 
\family typewriter
\series bold
token.FileSet
\family default
\series default
 хранит набор объектов 
\family typewriter
\series bold
token.File
\family default
\series default
, для каждого из которых определено базовое смещение и длина.
 Базовые смещения назначаются файлам таким образом, что любая позиция в
 любом файле из набора 
\family typewriter
\series bold
token.FileSet 
\family default
\series default
однозначно определяется целым числом.
 Набор 
\family typewriter
\series bold
token.FileSet
\family default
\series default
 заполняется синтаксическим анализатором.
\end_layout

\begin_layout Enumerate
Объект типа 
\family typewriter
\series bold
token.File
\family default
\series default
, кроме всего прочего, хранит информацию о переносах строк в соответствующем
 файле и предоставляет функции по преобразованию числовых смещений в классически
е файловые координаты вида {имя файла, строка, столбец}.
\end_layout

\begin_layout Standard
Корректная информация о координатах узлов синтаксического дерева в файле
 необходима принтеру для адекватной печати этого дерева в исходный код.
\end_layout

\begin_layout Subsubsection
Пакет 
\begin_inset Quotes fld
\end_inset

go/printer
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:Пакет-go/printer"

\end_inset


\end_layout

\begin_layout Standard
Пакет 
\begin_inset Quotes fld
\end_inset

go/printer
\begin_inset Quotes frd
\end_inset

 из стандартной библиотеки пакетов Go содержит типы и функции, позволяющие
 преобразовать синтаксическое дерево в исходный код на языке Go.
\end_layout

\begin_layout Standard
Тип 
\family typewriter
\series bold
Config
\family default
\series default
 описывает набор настроек для печати, таких как, например, длина табуляции
 в пробелах.
 Для типа 
\family typewriter
\series bold
Config
\family default
\series default
 определеня одна функция 
\family typewriter
\series bold
Fprintf()
\family default
\series default
, которая производит печать переданного ей синтаксического дерева.
 Также, аргументами функции являются значение интерфейсного типа 
\family typewriter
\series bold
io.Writer
\family default
\series default
, в который будет производиться печать, и набор 
\family typewriter
\series bold
token.FileSet
\family default
\series default
, предоставляющий информацию о координатах узлов.
 
\end_layout

\begin_layout Standard
При подготовке измененного синтаксического дерева к печати важно соответствующим
 образом скорректировать информацию о координатах, чтобы она соответствовала
 измененному дереву.
 Это усложняется тем, что информация о координатах распределена по трем
 объектам.
 Смещения границ узлов хранятся непосредственно в синтаксическом дереве,
 а информация, позволяющая перевести смещение в координаты, хранится в соответст
вующем описателе типа 
\family typewriter
\series bold
token.File
\family default
\series default
 и в наборе 
\family typewriter
\series bold
token.FileSet
\family default
\series default
.
 Более подробно проблемы, связанные с преобразованием координат, будут описаны
 в подразделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Подготовка-синтаксического-дерев"

\end_inset

.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Проектирование системы рефакторинга
\end_layout

\begin_layout Standard
В этом разделе описана структура разработанной программной системы и алгоритмы
 ее работы.
 
\end_layout

\begin_layout Standard
В общем, выполнение одного рефакторинга проводится в четыре этапа:
\end_layout

\begin_layout Enumerate
Подготовка входной программы.
 Необходима для корректной работы системы с программой.
 Производится один раз, перед первым использованием системы с данной программой.
\end_layout

\begin_layout Enumerate
Анализ поданной на вход программы.
\end_layout

\begin_layout Enumerate
Проведение преобразований синтаксического дерева, реализующих выбранный
 рефакторинг.
\end_layout

\begin_layout Enumerate
Сохранение результата.
\end_layout

\begin_layout Standard
Далее, каждый из этапов будет рассмотрен подробнее.
\end_layout

\begin_layout Subsection
Подготовка исходной программы
\end_layout

\begin_layout Standard
Для корректной работы системы рефакторинга, ей необходимо сообщить некоторую
 информацию о преобразуемой программе.
 Часть этой информации носит статический характер, поэтому целесообразно
 сообщить ее единственный раз, перед первым проведением рефакторинга.
 В дальнейшем, программа будет получать эту информацию автоматически.
\end_layout

\begin_layout Standard
К статической информации о программе относится спикок пакетов, реализующих
 эту программу, а также, расположение исходного когда сторонних пакетов,
 используемых программой.
 Эта информация должна быть занесена пользователем в специальный файл конфигурац
ии перед первым использованием системы рефакторинга с программой.
\end_layout

\begin_layout Standard
Также, в исходниках стандартной библиотеки Go есть пакеты, содержимое которых
 зависит от операционной системы и аппаратной платформы.
 Для правильного анализа таких пакетов необходимо анализировать только файлы,
 из которых компилировался пакет на данной платформе.
 Makefile'ы таких пакетов содержат информацию, позволяющую определить точный
 набор файлов, который скомпилирован в данный пакет.
 Этот набор необходимо сообщить системе рефакторинга.
\end_layout

\begin_layout Standard
Так как язык Go очень молод, то стандартная библиотека постоянно претерпевает
 изменения, всвязи с чем меняется и набор файлов аппаратно и системно-зависимых
 пакетов.
 Поэтому было принято решение сохранять эту информацию в конфигурационных
 файлах.
\end_layout

\begin_layout Standard
После настройки конфигурационных файлов программа готова к проведению рефакторин
гов.
 Необходимые конфигурационные файлы и их формат будут подробнее описаны
 в руководстве пользователя в разделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Документация-библиотеки-рефактор"

\end_inset

.
\end_layout

\begin_layout Subsection
Фазы компиляции
\end_layout

\begin_layout Standard
Проведение лексического, синтаксического и семантического анализов программы
 являются, в общем случае, фазами компиляции.
 Ниже приведены термины теории компиляторов, которые будут использоваться
 в этой главе.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Символ
\series default
\shape default
 -- это именованная сущность программы, определяемая парой <name, info>,
 где name -- идентификатор сущности, info -- описание сущности.
 
\end_layout

\begin_layout Standard

\series bold
\shape italic
Таблица символов
\series default
\shape default
 -- это отображение идентификаторов символов, видимых в некотором узле синтаксич
еского дерева, в описания соответствующих этим символам сущностей.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Область
\series default
\shape default
 -- множество узлов синтаксического дерева, в которых по семантике языка
 программирования видимы одни и те же символы.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Вложенная область
\series default
\shape default
 -- это область, узлы которой являются дочерними по отношению к узлу другой
 области.
 Вложенная область расширяет таблицу символов родительского узла, причем
 некоторые символы могут быть экранированы.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Область видимости символа
\series default
\shape default
 -- область программы, в которой может использоваться идентификатор данного
 символа.
 Определяется семантикой языка.
 Если идентификатор символа может использоваться в некоторой области программы,
 то говорят что символ 
\shape italic
виден
\shape default
 в этой области.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Синтаксический анализ
\series default
\shape default
 -- определение принадлежности некоторой цепочки символов к некоторой контекстно
-свободной грамматике и построение дерева вывода цепочки в этой грамматике.
\end_layout

\begin_layout Standard

\series bold
\shape italic
Семантический анализ
\series default
\shape default
 -- построение таблицы символов для каждой области в дереве синтаксического
 разбора.
 На самом деле общая задача семантического анализа включает несколько подзадач,
 в том числе проверку кода на соответствие семантике языка.
 Однако разработанная система работает только с заведомо семантически верным
 кодом, поэтому, в данном контексте, задачей семантического анализа является
 построение множества таблиц символов.
\end_layout

\begin_layout Standard
Более подробно с основами теориии компиляторов можно ознакомиться в 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Синтаксический анализ
\end_layout

\begin_layout Standard
После чтения необходимой информации из конфигурационных файлов, система
 рефакторинга переходит к синтаксическому анализу.
 В разработанной системе синтаксический анализ производится с помощью пакетов
 из стандартной библиотеки языка Go (см.
 раздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Работа-с-исходными"

\end_inset

).
\end_layout

\begin_layout Standard
Синтаксический анализ производится в два этапа.
 На первом этапе анализируются все пакеты программы, указанные в конфигурационно
м файле.
 После этого, система изучает все операторы импорта и передает на синтаксический
 анализ недостающие пакеты из стандартной библиотеки языка Go.
 Этот процесс имеет рекурсивную природу и аналогичен обходу графа зависимостей
 в глубину.
 Это гарантирует, что все зависимости будут обработаны, и в полученном синтаксич
еском лесе не будет ни одной ссылки на пакеты, синтаксическое дерево которых
 отсутствует.
\end_layout

\begin_layout Standard
В процессе рекурсивного обхода операторов импорта для каждого пакета составляетс
я карта зависимостей.
 Она представляет собой словарь, ключом которого является адрес файла, а
 значением -- массив зависимостей этого файла.
 Зависимость представляется в виде специального символа 
\family typewriter
\series bold
PackageSymbol
\family default
\series default
, который представляет собой символ импортируемого пакета.
 Этот символ хранит ссылку на объект, полностью описывающий импортируемый
 пакет, а также имя, которое присвоено этому пакету в данном файле.
 
\end_layout

\begin_layout Standard
Символы типа 
\family typewriter
\series bold
PackageSymbol
\family default
\series default
 имеют нехарактерную для остальных символов область видимости -- в пределах
 одного файла.
 Поэтому они не принадлежат ни одной реально существующей таблице символов
 и используются специальным образом, что описано более подробно в подразделе
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Семантический-анализ"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Семантический анализ
\begin_inset CommandInset label
LatexCommand label
name "sub:Семантический-анализ"

\end_inset


\end_layout

\begin_layout Standard
После синтаксического анализа система рефакторинга переходит к семантичекому
 анализу полученного синтаксического леса.
 Семантический анализатор реализован в четыре прохода:
\end_layout

\begin_layout Enumerate
Анализ глобальных типов данных.
\end_layout

\begin_layout Enumerate
Анализ сигнатур функций и методов
\end_layout

\begin_layout Enumerate
Анализ глобальных переменных и констант
\end_layout

\begin_layout Enumerate
Анализ тел функций и методов
\end_layout

\begin_layout Standard
Порядок проходов выбран таким образом, чтобы перед каждым следующим проходом
 были созданы все символы, которые могут понадобиться во время этого прохода.
 Например, для анализа сигнатур методов, системе необходимо знать о типах
 данных, которые могут быть использованы при объявлении параметров.
 В то же время, в рамках этого прохода системе еще не нужна информация о
 глобальных переменных и константах, потому что их использование в сигнатурах
 невозможно.
\end_layout

\begin_layout Standard
Составляемый набор таблиц символов состоит из блоков, имеющих древовидную
 структуру.
 Таблица символов, находящаяся в некотором узле такого дерева, описывает
 определенную область программы.
 При этом, таблицы, находящиеся в родительских узлах, являются 
\shape italic
открытыми
\shape default
 для дочерних, то есть область, описанная таблицей дочернего узла, является
 вложенной для области, описанной в родительском узле.
\end_layout

\begin_layout Standard
Например, таблицы символов, представляющие функцию 
\family typewriter
\series bold
f1
\family default
\series default
, представлены на рисунке 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Структура-таблиц-символов"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func f1(a bool,b string) (res string) {
\end_layout

\begin_layout Plain Layout

	var c string = "hello"
\end_layout

\begin_layout Plain Layout

	if a {
\end_layout

\begin_layout Plain Layout

        var d string = " world!"
\end_layout

\begin_layout Plain Layout

		return c + d
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	return c + d + b
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename symbolTables.png
	scale 60

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Структура-таблиц-символов"

\end_inset

Структура таблиц символов функции 
\family typewriter
\series bold
f1
\family default
\series default
.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Основным деревом таблиц символов из получаемого в результате семантического
 анализа набора, является дерево пакетов анализируемой программы.
 Корнем этого дерева является таблица символов 
\family typewriter
\series bold
Basic
\family default
\series default
, содержащая встроенные идентификаторы языка Go, а именно встроенные типы
 данных, функции и константы 
\family typewriter
\series bold
nil
\family default
\series default
, 
\family typewriter
\series bold
true
\family default
\series default
 и 
\family typewriter
\series bold
false
\family default
\series default
.
 Дочерними узлами для таблицы 
\family typewriter
\series bold
Basic
\family default
\series default
 являются таблицы 
\family typewriter
\series bold
Root
\family default
\series default
, по одной на каждый пакет программы.
 В таблице 
\family typewriter
\series bold
Root
\family default
\series default
 каждого пакета хранятся глобальные типы, переменные, константы и функции
 этого пакета.
 Таблица локальных переменнх некоторой функции пакета является дочерней
 к таблице 
\family typewriter
\series bold
Root
\family default
\series default
 этого пакета.
\end_layout

\begin_layout Standard
Также, существуют деревья таблиц символов, не связанные отношением вложенности
 с таблицей 
\family typewriter
\series bold
Basic
\family default
\series default
.
 Примером такого дерева является вырожденное дерево, состоящее из одной
 таблицы полей типа-структуры.
 Наличие механизма встраивания означает, что такие таблицы символов тоже
 могут выстраивать деревья.
 Также, примером таблицы символов, не являющейся дочерней таблицы 
\family typewriter
\series bold
Basic
\family default
\series default
, является список параметров в сигнатуре метода.
 В то же время, эта таблица является родительской для таблицы локальных
 переменных этого метода.
\end_layout

\begin_layout Standard
Символы и таблицы символов системы рефакторинга реализованы в пакете 
\family typewriter
\series bold
st
\family default
\series default
.
 Все символы, создаваемые семантическим анализатором, реализуют интерфейс
 
\family typewriter
\series bold
st.Symbol
\family default
\series default
.
 Этот интерфейс включает несколько методов, в том числе:
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
Name() string
\family default
\series default
 -- имя символа.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
Scope() *SymbolTable
\family default
\series default
 -- таблица символов, где символ объявлен.
 То есть символ виден в таблице 
\family typewriter
\series bold
Scope()
\family default
\series default
 и в таблицах, дочерних для нее.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
Identifiers() IdentSet
\family default
\series default
 -- список вхождений символа во все файлы, проанализированные системой.
\end_layout

\begin_layout Standard
Все таблицы символов в системе имеют тип 
\family typewriter
\series bold
st.SymbolTable
\family default
\series default
.
 Эта структура хранит список символов и список таблиц, открытых (родительских)
 для текущей таблицы.
 Для типа st.SymbolTable определено несколько методов, основные приведены
 ниже:
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
AddSymbol(s Symbol)
\family default
\series default
 -- добавляет символ в текущую таблицу символов.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
AddOpenedScope(t *SymbolTable)
\family default
\series default
 -- добавляет таблицу символов 
\family typewriter
\series bold
t
\family default
\series default
 как родительскую.
 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
LookUp(name string, filename string) (Symbol, bool)
\family default
\series default
 -- производит поиск символа с именем 
\family typewriter
\series bold
name
\family default
\series default
 в данной таблице символов.
 Возвращает пару значений, первое из которых хранит найденный символ, а
 второе -- флаг успешности операции.
\begin_inset Newline newline
\end_inset

Параметр 
\family typewriter
\series bold
filename
\family default
\series default
 хранит имя файла, из которого было взято имя name.
 Он нужен для правильного поиска символов пакетов 
\family typewriter
\series bold
st.PackageSymbol
\family default
\series default
.
 Так как один и тот же импортируемый пакет в каждом конкретном файле может
 иметь разное имя или вообще не импортироваться, то для корректного поиска
 такого символа методу 
\family typewriter
\series bold
LookUp
\family default
\series default
 необходимо знать имя файла.
\begin_inset Newline newline
\end_inset

Реализация процедуры 
\family typewriter
\series bold
LookUp
\family default
\series default
 поддерживает экранирование символов во вложенных областях.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
ForEach(toDo func(sym Symbol))
\family default
\series default
 -- вызывает функцию 
\family typewriter
\series bold
toDo
\family default
\series default
 для каждого символа таблицы.
\end_layout

\begin_layout Subsubsection
Анализ глобальных типов данных
\end_layout

\begin_layout Standard
Первым проходом семантического анализа является составление списка глобальных
 типов для каждого пакета.
 Глобальным называется тип, объявленный вне какой-либо функции (Go позволяет
 объявлять типы внутри функций).
 Семантический анализатор совершает обход всех узлов синтаксического дерева,
 являющихся глобальными объявлениями типов.
 По каждому объявлению составляется соответствующий символ, который добавляется
 в таблицу 
\family typewriter
\series bold
Root
\family default
\series default
 текущего пакета.
 
\end_layout

\begin_layout Standard
В соответствии с семантикой языка Go, в пакете 
\family typewriter
\series bold
st
\family default
\series default
 системы рефакторинга объявлены следующие символы для представления типов
 данных Go:
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.BasicTypeSymbol
\family default
\series default
 -- базовый тип языка Go.
 Символы такого типа могут находиться только в таблице 
\family typewriter
\series bold
Basic
\family default
\series default
.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.ArrayTypeSymbol
\family default
\series default
 -- тип-массив.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.ChanTypeSymbol
\family default
\series default
 -- тип-канал.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.FunctionTypeSymbol
\family default
\series default
 -- тип-функция.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.InterfaceTypeSymbol
\family default
\series default
 -- тип-интерфейс.

\family typewriter
 
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.MapTypeSymbol
\family default
\series default
 -- тип-словарь.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.PointerTypeSymbol
\family default
\series default
 -- тип-указатель.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.StructTypeSymbol
\family default
\series default
 -- тип-структура.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.AliasTypeSymbol
\family default
\series default
 -- тип-псевдоним.
 Например, если есть объявление 
\family typewriter
\series bold
type
\family default
\series default
 
\family typewriter
\series bold
PS
\family default
\series default
 
\family typewriter
\series bold
T
\family default
\series default
, то тип 
\family typewriter
\series bold
PS
\family default
\series default
 является псевдонимом типа 
\family typewriter
\series bold
T
\family default
\series default
.
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
st.UnresolvedTypeSymbol
\family default
\series default
 -- символ, описывающий тип, который был неизвестен на момент создания символа.
 Такие символы могут возникать в течение первого прохода из-за произвольного
 порядка объявлений Go, а также из-за зависимостей между пакетами.
 К началу второго прохода все такие символы будут заменены корректными ссылками.
 
\end_layout

\begin_layout Standard
Все символы-типы реализуют интерфейс 
\family typewriter
\series bold
st.ITypeSymbol
\family default
\series default
.
 Этот интерфейс расширяет интерфейс 
\family typewriter
\series bold
st.Symbol
\family default
\series default
 и предоставляет доступ к методам типа.
\end_layout

\begin_layout Standard
Вхождение символа-типа в исходный код может быть реализовано двумя типами
 узлов синтаксического дерева.
 Символ, объявленный в анализируемом пакете, представляется идентификатором.
 Символ из импортируемого пакета представляется селектором единичной глубины
 (
\family typewriter
\series bold
p.Name
\family default
\series default
).
 В обоих случаях, если такой тип не был найден в таблице 
\family typewriter
\series bold
Root
\family default
\series default
 соответствующего пакета, то вместо него записывается заглушка типа 
\family typewriter
\series bold
st.UnresolvedTypeSymbol
\family default
\series default
, которая хранит информацию, позволяющую в последствии определить, каким
 символом ее нужно заменить.
\end_layout

\begin_layout Standard
Замена заглушек ссылками на настоящие символы осуществляется специальной
 процедурой после окончания первого прохода для всех пакетов.
 Для каждого пакета, функция перебирает все типы его таблицы 
\family typewriter
\series bold
Root
\family default
\series default
 и для каждого символа-типа запускает рекурсивный обход.
 В процессе обхода в самом символе, а так же во всех символах, на которые
 он ссылается, производится поиск и замена заглушек.
\end_layout

\begin_layout Standard
Итак, после первого прохода, семантический анализатор имеет в распоряжении
 таблицы символов 
\family typewriter
\series bold
Root
\family default
\series default
, по одной для каждого пакета, в которых хранятся символы всех глобальных
 типов, объявленных в программе.
 Это позволяет перейти ко второму проходу: анализу сигнатур функций и методов.
\end_layout

\begin_layout Subsubsection
Анализ сигнатур функций и методов
\end_layout

\begin_layout Standard
В процессе второго прохода семантический анализатор обходит дерево синтаксическо
го разбора в поисках объявлений функций и методов.
 по каждому объявлению создается символ типа 
\family typewriter
\series bold
st.FunctionSymbol
\family default
\series default
.
 Кроме реализации стандартного интерфейса 
\family typewriter
\series bold
st.Symbol
\family default
\series default
 такой символ содержит описание сигнатуры функции, в виде ссылки на объект
 типа 
\family typewriter
\series bold
st.FunctionType
\family default
\series default
, а также таблицу символов 
\family typewriter
\series bold
Locals
\family default
\series default
 для хранения символов локальных переменных.
\end_layout

\begin_layout Standard
Символ типа 
\family typewriter
\series bold
st.FunctionType
\family default
\series default
 описывает сигнатуру некоторой функции.
 Кроме реализации интерфейса 
\family typewriter
\series bold
st.ITypeSymbol
\family default
\series default
, этот тип содержит три таблицы символов: 
\family typewriter
\series bold
Parameters
\family default
\series default
, 
\family typewriter
\series bold
Results
\family default
\series default
 и 
\family typewriter
\series bold
Reciever
\family default
\series default
.
 Первая содержит параметры функции, вторая -- символы, через которые происходит
 возврат значений.
 Таблица 
\family typewriter
\series bold
Reciever
\family default
\series default
 содержит символ-приемник для методов и является пустой для функций.
\end_layout

\begin_layout Standard
Задачей семантического анализатора на втором проходе является создание символа-ф
ункции типа 
\family typewriter
\series bold
st.FunctionSymbol
\family default
\series default
 для каждого объявления функции и полное описание ее сигнатуры в соответствующем
 символе типа 
\family typewriter
\series bold
st.FunctionType
\family default
\series default
.
 Таблица 
\family typewriter
\series bold
Locals
\family default
\series default
 на данном проходе не заполняется.
 Созданный символ-функция добавляется в таблицу методов типа-приемника,
 при его наличии, а при его отсутствии -- в таблицу 
\family typewriter
\series bold
Root
\family default
\series default
 пакета, в котором функция была объявлена.
\end_layout

\begin_layout Standard
После второго прохода семантический анализатор обладает абсолютно полной
 информацией обо всех типах данных, объявленных в программе.
 Однако, перед третьим проходом необходимо провести вспомогательную процедуру,
 которая необходима для правильной работы системы с типами данных, в которых
 применено встраивание (см.
 раздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Типизация"

\end_inset

).
 Так как расширяющий тип получает возможность использовать все поля и методы
 встроенного типа, то семантическому анализатору необходимо установить отношение
 вложенности между соответствующими таблицами символов.
 А именно, таблица методов встраиваемого типа должна быть открыта для аналогично
й таблицы расширяющего типа.
 Если встраиваемый тип, также как и расширяемый, является структурой, соответств
ующие таблицы символов-полей также должны быть связаны аналогичным образом.
 
\end_layout

\begin_layout Subsubsection
Анализ глобальных переменных и констант
\end_layout

\begin_layout Standard
На третьем проходе семантический анализатор добавляет в таблицу 
\family typewriter
\series bold
Root
\family default
\series default
 каждого пакета глобальные переменные и константы.
 По аналогии с глобальными типами, глобальными переменными и константами
 называются те, которые объявлены вне какой-либо функции.
 
\end_layout

\begin_layout Standard
Любая переменная или константа описывается символом типа 
\family typewriter
\series bold
st.VariableSymbol
\family default
\series default
.
 Эта структура имеет поле 
\family typewriter
\series bold
VariableType
\family default
\series default
 типа 
\family typewriter
\series bold
st.ITypeSymbol
\family default
\series default
, ссылающееся на символ-тип, который имеет данная переменная.
\end_layout

\begin_layout Standard
Так как в Go глобальные переменные наряду с локальными могут объявляться
 без явного указания типа, то уже на этом проходе семантический анализатор
 использует парсер выражений.
 Парсер выражений получает на вход узел синтаксического дерева, который
 описывает выражение языка Go, а возвращает символ-тип, который имеет переданное
 выражение.
 
\end_layout

\begin_layout Standard
Вполне возможна ситуация, когда в правой части объявления переменной с неявным
 указанием типа может использоваться глобальная переменная другого пакета.
 Если на момент вычисления используемая переменная еще не была обработана
 семантическим анализатором, то верно определить тип выражения не удастся.
 Поэтому, по окончании прохода, семантический анализатор проводит вспомогательну
ю процедуру, в ходе которой пересчитывается тип переменных, с которыми возникли
 проблемы во время основной фазы прохода.
\end_layout

\begin_layout Standard
После анализа глобальных переменных и констант семантический анализатор
 обладает всей необходимой информацией для начала завершающего прохода --
 анализа тел функций и методов.
\end_layout

\begin_layout Subsubsection
Анализ тел функций и методов
\end_layout

\begin_layout Standard
На завершающем проходе семантический анализатор заполняет таблицы 
\family typewriter
\series bold
Locals
\family default
\series default
 всех функций и методов, а также порождает и заполняет таблицы вложенных
 областей.
 Проходя по-очереди все операторы текущей функции, анализатор ищет объявления
 переменных, создает и добавляет соответствующие символы в текущую таблицу
 символов.
 При необходимости, семантический анализатор вызывает парсер выражений.
\end_layout

\begin_layout Standard
Если анализатор встречает блочный оператор (например, 
\family typewriter
\series bold
if
\family default
\series default
-
\family typewriter
\series bold
else
\family default
\series default
 или 
\family typewriter
\series bold
for
\family default
\series default
), то для каждого вложенного блока создается новая таблица символов.
 Текущая таблица символов становится для новой таблицы открытой, и, на время
 обхода блока, новая таблица назначается текущей.
 Таким образом, полученное дерево таблиц соответствует структуре блоков
 в теле функции.
\end_layout

\begin_layout Standard
Важной функцией данного прохода (как, впрочем, и всех предыдущих) является
 составление карты идентификаторов программы.
 Карта идентификаторов -- это словарь, отображающий множество узлов-идентификато
ров синтаксического леса в множество символов.
 На все множество анализируемых пакетов создается одна такая карта, называемая
 
\family typewriter
\series bold
IdentMap
\family default
\series default
.
 С её помощью для любого идентификатора в синтаксическом дереве любого пакета
 можно определить, вхождением какого символа является этот идентификатор.
\end_layout

\begin_layout Standard
Обратное отображение реализовано в виде массива идентификаторов 
\family typewriter
\series bold
Identifiers
\family default
\series default
, который заполняется для каждого символа.
 Он позволяет быстро перебрать все вхождения символа в синтаксический лес
 пакетов программы.
\end_layout

\begin_layout Standard
Во процессе каждого обхода семантический анализатор обрабатывает некоторое
 множество узлов.
 Для каждого найденного идентификатора, в зависимости от ситуации, определяется
 соответствующий символ или создается новый.
 Идентификатор добавляется в массив 
\family typewriter
\series bold
Identifiers
\family default
\series default
 этого символа, а пара <идентификатор, символ> добавляется в карту 
\family typewriter
\series bold
IdentMap
\family default
\series default
.
 
\end_layout

\begin_layout Standard
Алгоритм работы семантического анализатора не гарантирует того, что каждый
 идентификатор будет обработан единожды.
 Это обусловлено наличием некоторых дополнительных процедур разрешения конфликто
в, о которых рассказано в разделах, посвященных соответствующим проходам.
 Всвязи с этим, карта идентификаторов 
\family typewriter
\series bold
IdentMap
\family default
\series default
, и массивы идентификаторов 
\family typewriter
\series bold
Identifiers
\family default
\series default
 реализованы в виде словарей, ключами которых являются идентификаторы в
 синтаксическом дереве.
 В словаре не может быть двух элементов с одинаковыми ключами, что решает
 проблему повторной обработки одного идентификатора.
\end_layout

\begin_layout Subsection
Этапы проведения рефакторинга
\end_layout

\begin_layout Standard
После проведения семантического анализа, система приступает к осуществлению
 своей основной задачи -- проведению рефакторинга.
 Эту задачу система выполняет в несколько этапов:
\end_layout

\begin_layout Enumerate
Проверка входных данных
\end_layout

\begin_layout Enumerate
Внесение необходимых изменений в синтаксическое дерево
\end_layout

\begin_layout Enumerate
Подготовка синтаксического дерева к печати в файл
\end_layout

\begin_layout Enumerate
Сохранение сделанных изменений
\end_layout

\begin_layout Standard
В этом разделе подробно описаны эти этапы проведения рефакторинга.
\end_layout

\begin_layout Subsubsection
Проверка входных данных
\end_layout

\begin_layout Standard
Кроме исходной программы, каждый рефакторинг требует некоторый набор дополнитель
ной информации.
 В общем случае, корректность такой информации можно достоверно определить
 лишь после семантического анализа.
 Например, рефакторингу 
\begin_inset Quotes fld
\end_inset

переименование
\begin_inset Quotes frd
\end_inset

 нужно указать координаты любого вхождения символа, который нужно переименовать,
 и его новое имя.
 В этом случае, только после семантического анализа можно определить, не
 вызовет ли новое имя конфликтов в области видимости символа.
\end_layout

\begin_layout Standard
Проведенные выше рассуждения показывают необходимость тщательной проверки
 исходных данных для запрошенного пользователем рефакторинга.
 Самые интересные варианты некорректного рефакторинга, связанные с семантикой
 языка Go, представлены в главах 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Основные-сведения"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Семантика-преобразований"

\end_inset

.
 
\end_layout

\begin_layout Standard
Обнаружение некоторых ошибок возможно лишь в процессе проведения рефакторинга.
 Например, при поиске выражения которое нужно извлечь в метод в рамках рефактори
нга 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

, может оказаться, что, несмотря на корректность задания его границ, такое
 выражение нельзя извлекать в метод.
 Примером может служить выражение, стоящее в левой части оператора присваивания.
 Замена такого выражения вызовом метода, который просто его возвращает,
 очевидно, нарушит семантику программы.
\end_layout

\begin_layout Subsubsection
Изменение синтаксического дерева
\begin_inset CommandInset label
LatexCommand label
name "sub:Изменение-синтаксического-дерева"

\end_inset


\end_layout

\begin_layout Standard
Этот этап проведения рефакторинга сильно зависит от выбранного пользователем
 преобразования.
 Далее разобран процесс проведения каждого рефакторинга в контексте изменений
 синтаксического дерева.
 Описания приведены в порядке возрастающей сложности проведения соответствующего
 преобразования.
\end_layout

\begin_layout Paragraph
Сортировка объявлений.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

сортировка объявлений
\begin_inset Quotes frd
\end_inset

 по полученной от пользователя команде формирует отношение превосходства
 для объявлений верхнего уровня.
 На основе этого отношения производится сортировка массива объявлений в
 синтаксическом дереве файла.
\end_layout

\begin_layout Paragraph
Переименование.
\end_layout

\begin_layout Standard
Для рефакторинга 
\begin_inset Quotes fld
\end_inset

переименование
\begin_inset Quotes frd
\end_inset

 требуется переименовать все вхождения заданного символа.
 Это делается простым перебором узлов из массива 
\family typewriter
\series bold
Idents
\family default
\series default
 с присваиванием нового имени полю 
\family typewriter
\series bold
Name
\family default
\series default
 каждого узла.
\end_layout

\begin_layout Paragraph
Реализация интерфейса.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

реализация интерфейса
\begin_inset Quotes frd
\end_inset

 для заданного пользователем символа-типа должен дополнить множество его
 методов таким образом, чтобы он реализовывал некоторый интерфейс, также
 заданный пользователем.
 Для этого, система рефакторинга сначала перебирает уже объявленные методы
 заданного типа.
 В случае обнаружения уже реализованных методов интерфейса, система будет
 добавлять лишь недостающие методы.
 Изменение синтаксического дерева в этом случае заключается в добавлении
 узлов-объявлений в конец массива объявлений.
\end_layout

\begin_layout Standard
Обнаружение у типа метода, имя которого совпадает с именем интерфейсного
 метода, но сигнатура отличается, является случаем, когда рефакторинг нельзя
 довести до конца без изменения семантики работы программы.
 Поэтому, в этом случае, система выдаст пользователю сообщение об ошибке
 и не будет проводить рефакторинг.
\end_layout

\begin_layout Paragraph
Извлечение интерфейса.
\end_layout

\begin_layout Standard
Для проведения рефакторинга 
\begin_inset Quotes fld
\end_inset

извлечение интерфейса
\begin_inset Quotes frd
\end_inset

 система обходит тело заданного пользователем метода и составляет список
 всех обращений к заданному параметру.
 Для того, чтобы извлечение интерфейса было возможным, этот список должен
 состоять лишь из вызовов методов этого параметра, а также небольшого набора
 других действий (см.
 раздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Извлечение-интерфейса"

\end_inset

).
 Успешное проведение рефакторинга подразумевает внесение двух изменений
 в синтаксическое дерево: добавление объявления интерфейса в список объявлений,
 а также замена типа параметра на идентификатор созданного интерфейса.
\end_layout

\begin_layout Paragraph
Извлечение метода.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

 создает метод на основе некоторой последовательности узлов-операторов,
 и заменяет эту последовательность оператором вызова нового метода.
 Сначала, система по заданным пользователем координатам выделяет подмножество
 синтаксического дерева, которое нужно извлечь в метод.
 Затем, полученное множество анализируется на предмет зависимостей от внешнего
 кода, которые нужно выделить в параметры создаваемого метода.
 После этого система приступает к формированию узла, представляющего объявление
 нового метода и добавлению этого узла в массив объявлений файла.
 В завершение, создается узел-вызов, который подставляется в синтаксическое
 дерево вместо извлеченного набора узлов.
\end_layout

\begin_layout Standard
Сложность проведения рефакторинга 
\begin_inset Quotes fld
\end_inset

извлечения метода
\begin_inset Quotes frd
\end_inset

 обуславливается несколькими ньюансами.
 Во-первых, извлекаемый блок операторов должен удовлетворять двум условиям:
\end_layout

\begin_layout Enumerate
Все операторы блока должны находиться в одной области видимости.
 При наличии в блоке операторов с вложенными областями (например, 
\family typewriter
\series bold
if
\family default
\series default
-
\family typewriter
\series bold
else
\family default
\series default
 или 
\family typewriter
\series bold
for
\family default
\series default
), эти операторы должны полностью принадлежать извлекаемому множеству.
\end_layout

\begin_layout Enumerate
Извлекаемый блок не должен содержать операторов возврата 
\family typewriter
\series bold
return
\family default
\series default
, в том числе и во вложенных областях.
\end_layout

\begin_layout Standard
Во-вторых, поиск зависимостей от внешнего кода подразумевает динамическое
 составление списка переменных, объявленных в пределах извлекаемого кода.
 При этом, такой список должен быть структурированным, в соответствии с
 областями видимости операторов.
 Пусть, например, система извлекает следующий код:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

if true{
\end_layout

\begin_layout Plain Layout

	b := getB()
\end_layout

\begin_layout Plain Layout

	println(b)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

println(b)
\end_layout

\end_inset

Здесь переменная 
\family typewriter
\series bold
b
\family default
\series default
, объявленная внутри условного блока, вне его не видна.
 Поэтому, переменная 
\family typewriter
\series bold
b
\family default
\series default
, к которой производится обращение в последнем операторе извлекаемого блока
 должна быть вынесена в параметр.
 
\end_layout

\begin_layout Standard
Если в извлекаемом блоке объявлена переменная, которая используется вне
 этого блока, то система не проводит рефакторинг и сообщает пользователю
 об ошибке.
\end_layout

\begin_layout Standard
Еще одной проблемой, возникающей в процессе извлечения метода, является
 изменение переменных, которые являются параметрами извлекаемого метода.
 Если в извлекаемом коде производится присваивание к такой переменной, либо
 к этой переменной применяется оператор взятия адреса, то такую переменную
 необходимо передавать по указателю.
 Рассмотирм процесс извлечения следующего кода:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

a += 10
\end_layout

\begin_layout Plain Layout

changeA(&a)
\end_layout

\end_inset

Здесь значение переменной 
\family typewriter
\series bold
a
\family default
\series default
, которая, очевидно, является внешней зависимостью и должна быть вынесена
 в параметр, изменяется.
 Если провести извлечение без изменений, то изменения, проводимые методом,
 не будут видны вызывающему коду:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func wrong(a int){
\end_layout

\begin_layout Plain Layout

	a += 10
\end_layout

\begin_layout Plain Layout

	changeA(&a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Поэтому, в таком случае применяется передача по указателю, и процедуре рефактори
нга нужно провести дополнительные преобразования синтаксического дерева:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func right(a *int){
\end_layout

\begin_layout Plain Layout

	*a += 10
\end_layout

\begin_layout Plain Layout

	changeA(a)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Соответственно, вызов, которым будет заменен извлекаемый код, должен выглядеть
 следующим образом:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

right(&a)
\end_layout

\end_inset

Теперь код метода и вызывающий код работают с одной и той же ячейкой памяти,
 семантика кода не нарушена.
\end_layout

\begin_layout Paragraph
Встраивание метода.
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

встраивание метода
\begin_inset Quotes frd
\end_inset

 является преобразованием, обратным к рефакторингу 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

.
 Система рефакторинга берет все операторы из тела метода и вставляет их
 вместо вызова, с подстановкой параметров.
 Для проведения этой подстановки каждому параметру ставится в соответствие
 выражение, переданное во встраиваемый вызов на его месте.
 Затем делается копия синтаксического поддерева тела метода.
 Система рефакторинга производит обход этого поддерева и заменяет вхождение
 каждого параметра соответствующим ему выражением.
 Подготовленное таким образом множество узлов-операторов вставляется вместо
 узла-вызова в массив операторов, содержащий этот вызов.
\end_layout

\begin_layout Standard
Основной проблемой, возникающей при встраивании кода, является разрешение
 конфликтов имен.
 Так как код из одной области встраивается в другую область, совершенно
 не связанную с исходной, то вполне вероятны конфликты имен встраиваемых
 переменных с переменными исходной области.
 Пример такого конфликта рассмотрен в разделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Встраивание-метода"

\end_inset

.
 
\end_layout

\begin_layout Standard
Для разрешения таких конфликтов, система рефакторинга ищет новые имена для
 переменных метода, конфликтующих с новой областью.
 Это делается следующим образом: к старому имени приписывается число 
\family typewriter
\series bold
0
\family default
\series default
.
 Если новое имя также вступает в конфликт с новой областью, то приписанное
 число увеличивается на единицу.
 Таким образом, подходящее имя вскоре будет найдено.
\end_layout

\begin_layout Standard
В случае множества конфликтов встроенный код может читаться гораздо хуже,
 чем исходный код метода, из-за программно составленных имен с цифрами.
 В таком случае пользователь может применить рефакторинг 
\begin_inset Quotes fld
\end_inset

переименование
\begin_inset Quotes frd
\end_inset

 для приведения кода в читаемый вид.
\end_layout

\begin_layout Standard
Еще одной проблемой при встраивании метода является синхронизация объявлений
 импорта.
 Если встраивается метод из другого файла, то возможно несовпадение имен,
 под которыми импортируются некоторые пакеты.
 Также, в файле, в котором производится встраивание, может вообще не быть
 импортирован пакет, используемый во встраиваемом коде.
 Поэтому, процедура рефакторинга должна анализировать пакетные зависимости
 встраиваемого кода и синхронизировать их с окружением, в которое код встраивает
ся.
 Если конечный файл импортирует необходимый пакет под другим именем, необходимо
 переименовать все вхождения этого пакета во встраиваемом коде.
 Если же необходимый пакет не импортируется, необходимо добавить соответствующий
 оператор импорта.
\end_layout

\begin_layout Subsubsection
Подготовка синтаксического дерева к печати в файл 
\begin_inset CommandInset label
LatexCommand label
name "sub:Подготовка-синтаксического-дерев"

\end_inset


\end_layout

\begin_layout Standard
Внесение изменений в синтаксическое дерево должно сопровождаться соответствующим
и изменениями в информации о координатах узлов в файле.
 Так как, на данный момент, синтаксическое дерево, получаемое с помощью
 пакетов стандартной библиотеки Go, не предоставляет явный интерфейс внесения
 изменений, то все изменения вносятся 
\begin_inset Quotes fld
\end_inset

вручную
\begin_inset Quotes frd
\end_inset

.
 Ниже подробнее описан механизм синхронизации информации о координатах с
 изменениями синтаксического дерева.
\end_layout

\begin_layout Standard
Рассмотрим задачу вставки в синтаксическое дерево узла из другого файла.
 Для возвращения информации о координатах в корректное состояние необходимо
 узнать длину вставленного узла и увеличить на нее координаты узлов, расположенн
ых в файле после места вставки.
 Узел считается расположенным после места вставки, если координата его начала
 больше, чем координата места вставки.
 
\end_layout

\begin_layout Standard
Координаты вставленного узла необходимо привести к базису файла, в который
 он вставлен.
 Для этого, для каждой координаты вставляемого узла и всех его дочерних
 узлов проводится операция нормализации: из нее вычитается смещение (см.
 подраздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Пакет-go/token"

\end_inset

) начала вставляемого участка, и прибавляется смещение места вставки.
 
\end_layout

\begin_layout Standard
После этих преобразований координаты в синтаксическом дереве становятся
 корректными, однако необходимо, также, исправить информацию о переносах
 строк.
 Сначала, координаты всех переносов строк, находящихся после места вставки,
 увеличиваются на длину узла.
 Затем, с помощью специальной процедуры, система рефакторинга определяет
 количество переносов строк в пределах вставляемого узла, и их координаты.
 Для этого, очевидно, система использует информацию о файле, из которого
 узел был взят.
 После этого, набор координат переносов строк нормализуется к новому файлу,
 подобно координатам узлов.
 Нормализованные координаты вставляются в массив координат переносов строк
 изменяемого файла, после чего, информация о переносах строк находится в
 корректном состоянии.
\end_layout

\begin_layout Standard
На рисунках 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Синхронизация-координат-переносов-1"

\end_inset

 и 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Синхронизация-координат-переносов-2"

\end_inset

 представлена визуализация описанного процесса синхронизации координат переносов
 строк.
 Рисунок 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Синхронизация-координат-переносов-1"

\end_inset

 содержит исходный фрагмент кода файла X, с базовым смещением BaseX, и вставляем
ый в файл X фрагмент кода файла Y, с базовым смещением BaseY.
 Смещения переносов строк в файлах X и Y обозначены соответственно X1-X5
 и Y1-Y3.
 Смещение начала участка вставляемого кода обозначено Y0.
 Вставка производится сразу после переноса строки X2, это место указано
 на рисунке стрелкой.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename linebreaks1.png
	scale 70
	BoundingBox 0bp 0bp 775bp 378bp
	clip

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Синхронизация-координат-переносов-1"

\end_inset

Синхронизация координат переносов строк.
 Исходные данные.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
На рисунке 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Синхронизация-координат-переносов-2"

\end_inset

 представлен результат операции вставки.
 Как мы видим, все вставленные строки, обозначенные пунктиром, имеют соответству
ющим образом нормализованные координаты переносов.
 Координаты переносов строк файла X, которые находились после места вставки,
 смещены на длину вставленного фрагмента.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename linebreaks2.png
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Синхронизация-координат-переносов-2"

\end_inset

Синхронизация координат переносов строк.
 Результат.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Кроме задачи вставки узла, система рефакторинга приходится решать задачи
 удаления и замены узлов, а также, изменение длины существующего узла.
 Процесс корректировки информации о координатах во всех этих случаях аналогичен
 вышеописанному.
 Стоит отметить, что, в случае работы с узлами из разных файлов, невозможно
 провести корректировку без полной информации о координатах узлов и переносов
 строк в этих файлах.
 Поэтому описанный механизм не предусматривает работу с узлами, для которых
 такая информация отсутствует.
\end_layout

\begin_layout Standard
Изменения синтаксического дерева, описанные в подразделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Изменение-синтаксического-дерева"

\end_inset

, разбиваются на множество простых операций вставки/удаления узла.
 Поэтому, этапы внесения изменений и корректировки координатной информации
 на самом деле проводятся параллельно.
 То есть, после каждого изменения синтаксического дерева проводится корректировк
а координат, и только после этого система приступает к следующему изменению.
\end_layout

\begin_layout Subsubsection
Сохранение изменений
\end_layout

\begin_layout Standard
После всех манипуляций, новое синтаксическое дерево необходимо сохранить
 в файл.
 Это делается с помощью стандартной библиотеки пакетов Go (см.
 подраздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Пакет-go/printer"

\end_inset

).
 Система рефакторинга открывает исходный файл в режиме записи, стирает его
 содержимое и печатает новое синтаксическое дерево.
 
\end_layout

\begin_layout Standard
Большинство рефакторингов, реализованных в системе, подразумевают внесение
 изменений в один файл программы.
 Однако, рефакторинг переименование, в зависимости от распространенности
 символа, может изменить несколько файлов и даже несколько пакетов.
 Поэтому, в процессе переименования составляется список файлов, которые
 подлежат перезаписи.
 После проведения всех изменений в синтаксическом дереве, файлы из этого
 списка по-очереди передаются подпрограмме сохранения.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Руководство пользователя
\end_layout

\begin_layout Standard
Данное руководство состоит из двух частей: документации к библиотеке, реализующе
й функции системы рефакторинга, и к тестовой программе, которая предоставляет
 интерфейс командной строки к функциям библиотеки.
\end_layout

\begin_layout Subsection
Документация библиотеки рефакторинга 
\begin_inset CommandInset label
LatexCommand label
name "sub:Документация-библиотеки-рефактор"

\end_inset


\end_layout

\begin_layout Subsubsection
Проект GoRefactor
\begin_inset CommandInset label
LatexCommand label
name "sub:Проект-GoRefactor"

\end_inset


\end_layout

\begin_layout Standard
Библиотека GoRefactor, реализующая систему рефакторинга, работает с программами
 на языке Go.
 Такая программа может состоять из нескольких пакетов и должна иметь определенну
ю структуру.
 На рис.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Структура-проекта"

\end_inset

 приведена схема расположения пакетов некоторой программы, удовлетворяющей
 условиям работы библиотеки рефакторинга.
 Все пакеты программы размещены в одной папке (
\family typewriter
\series bold
src
\family default
\series default
 на рис.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Структура-проекта"

\end_inset

), каждый пакет представляет собой папку, названную его именем, в которой
 лежат все файлы пакета.
 Файлы одного пакета должны быть изолированы от файлов другого.
 Пакеты также могут храниться во вложенных папках (
\family typewriter
\series bold
nested
\family default
\series default
 на рис.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Структура-проекта"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename project_1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Структура-проекта"

\end_inset

Структура проекта GoRefactor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Информация о проекте хранится в конфигурационном файле 
\family typewriter
\series bold
goref.cfg
\family default
\series default
, который находится в корневой директории проекта 
\family typewriter
\series bold
src
\family default
\series default
.
 Ниже приведено описание его структуры.
\end_layout

\begin_layout Standard
Первая секция конфигурационного файла 
\family typewriter
\series bold
goref.cfg
\family default
\series default
 называется 
\begin_inset Quotes fld
\end_inset

.packages
\begin_inset Quotes frd
\end_inset

 и содержит список всех пакетов, находящихся в папке 
\family typewriter
\series bold
src
\family default
\series default
 и вложенных папках.
 В качестве примера приведем секцию 
\begin_inset Quotes fld
\end_inset

.packages
\begin_inset Quotes frd
\end_inset

 для проекта самой библиотеки GoRefactor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

.packages
\end_layout

\begin_layout Plain Layout

st             refactoring/st
\end_layout

\begin_layout Plain Layout

utils          refactoring/utils
\end_layout

\begin_layout Plain Layout

errors         refactoring/errors
\end_layout

\begin_layout Plain Layout

packageParser  refactoring/packageParser
\end_layout

\begin_layout Plain Layout

program        refactoring/program
\end_layout

\begin_layout Plain Layout

printerUtil    refactoring/printerUtil
\end_layout

\begin_layout Plain Layout

refactoring    refactoring/refactoring
\end_layout

\begin_layout Plain Layout

main           _
\end_layout

\end_inset

Каждый пакет представлен строчкой, содержащей два поля, разделенных любым
 количеством пробелов и знаков табуляции.
 Первое поле хранит адрес директории пакета, относительно корневой директории.
 Вторым полем задается адрес в дереве пакетов Go, куда компилируется этот
 пакет.
 Этот адрес используется в операторе импорта.
\end_layout

\begin_layout Standard
Если пакет не сохраняется в дереве пакетов Go или не импортируется другими
 пакетами, для него во втором поле можно поставить знак '
\family typewriter
\series bold
_
\family default
\series default
'.
 В приведенном примере, пакет 
\family typewriter
\series bold
main
\family default
\series default
 компилируется не в библиотеку, а в исполняемый файл, и, следовательно,
 не сохраняется в дереве пакетов Go.
\end_layout

\begin_layout Standard
Вторая секция файла 
\family typewriter
\series bold
goref.cfg
\family default
\series default
 называется 
\begin_inset Quotes fld
\end_inset

.externPackages
\begin_inset Quotes frd
\end_inset

 и содержит описания пакетов, которые находятся вне директории 
\family typewriter
\series bold
src
\family default
\series default
, но используются в проекте.
 Если проект помимо своих пакетов использует лишь пакеты из стандартной
 библиотеки Go, то эту секцию можно опустить.
\end_layout

\begin_layout Standard
Приведем пример секции 
\begin_inset Quotes fld
\end_inset

.externPackages
\begin_inset Quotes frd
\end_inset

 некоторого проекта, использующего исходные коды библиотеки GoRefactor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

.externPackages 
\end_layout

\begin_layout Plain Layout

/home/username/goRefactor/src/errors        refactoring/errors
\end_layout

\begin_layout Plain Layout

/home/username/goRefactor/src/refactoring   refactoring/refactoring
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Каждый пакет представлен строчкой, аналогично секции 
\begin_inset Quotes fld
\end_inset

.packages
\begin_inset Quotes frd
\end_inset

.
 Единственное отличие состоит в том, что в первом поле указывается абсолютный
 путь к папке с исходным кодом пакета.
\end_layout

\begin_layout Standard
Пользователю библиотеки следует понимать, что если некоторый запрошенный
 рефакторинг затрагивает исходный код пакетов из секции 
\begin_inset Quotes fld
\end_inset

.externPackages
\begin_inset Quotes frd
\end_inset

, то он также будет изменен.
\end_layout

\begin_layout Standard
Последняя секция файла 
\family typewriter
\series bold
goref.cfg
\family default
\series default
 называется 
\begin_inset Quotes fld
\end_inset

.specialPackages
\begin_inset Quotes frd
\end_inset

 и содержит конфигурацию платформо-зависимых пакетов из стандартной библиотеки
 Go.
 На данный момент таких пакета три: 
\family typewriter
\series bold
syscall
\family default
\series default
, 
\family typewriter
\series bold
os
\family default
\series default
, 
\family typewriter
\series bold
runtime
\family default
\series default
.
 Поэтому секция 
\begin_inset Quotes fld
\end_inset

.specialPackages
\begin_inset Quotes frd
\end_inset

 будет выглядеть вот так:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

.specialPackages
\end_layout

\begin_layout Plain Layout

syscall
\end_layout

\begin_layout Plain Layout

os
\end_layout

\begin_layout Plain Layout

runtime
\end_layout

\end_inset

Каждому элементу секции 
\begin_inset Quotes fld
\end_inset

.specialPackages
\begin_inset Quotes frd
\end_inset

 должен соответствовать файл в корневой директории проекта.
 Он должен иметь имя, совпадающее с именем соответствующего пакета, и расширение
 '
\family typewriter
\series bold
.cfg
\family default
\series default
'.
 Рассмотрим файл 
\family typewriter
\series bold
syscall.cfg
\family default
\series default
 для операционной системы Linux на процессоре Intel:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

str.go
\end_layout

\begin_layout Plain Layout

syscall.go
\end_layout

\begin_layout Plain Layout

syscall_386.go
\end_layout

\begin_layout Plain Layout

syscall_linux.go
\end_layout

\begin_layout Plain Layout

syscall_linux_386.go
\end_layout

\begin_layout Plain Layout

zerrors_linux_386.go
\end_layout

\begin_layout Plain Layout

zsyscall_linux_386.go
\end_layout

\begin_layout Plain Layout

zsysnum_linux_386.go
\end_layout

\begin_layout Plain Layout

ztypes_linux_386.go
\end_layout

\begin_layout Plain Layout

syscall_unix.go
\end_layout

\begin_layout Plain Layout

exec_unix.go
\end_layout

\end_inset

В конфигурационном файле платформо-зависимого пакета должны быть указаны
 названия всех файлов, из которых пакет компилировался на данной платформе.
 Этот список можно взять из соответствующего Makefile'а в дереве пакетов
 Go.
\end_layout

\begin_layout Standard
Максимально упростить настройку проекта GoRefactor может команда 
\family typewriter
\series bold
init
\family default
\series default
 тестовой утилиты goref, которая описана в разделе 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Руководство-тестовой-утилиты"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Установка библиотеки GoRefactor
\end_layout

\begin_layout Standard
Для установки библиотеки GoRefactor требуется операционная система Linux,
 а также установленный компилятор языка Go.
 Документацию по установке компилятора языка Go можно найти по адресу 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://golang.org/doc/install.html
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Дистрибутив библиотеки GoRefactor можно скачать с репозитория на GitHub,
 по адресу 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/rulERR/GoRefactor/
\end_layout

\end_inset

.
 После того, как дистрибутив был записан на жесткий диск, пользователь может
 скомпилировать и установить библиотеку, запустив bash-скрипт 
\family typewriter
\series bold
build
\family default
\series default
 из папки 
\family typewriter
\series bold
scripts
\family default
\series default
.
 
\end_layout

\begin_layout Standard
Установка скопирует пакеты библиотеки GoRefactor в дерево Go, после чего
 их можно использовать в других программах.
 
\end_layout

\begin_layout Standard
Для проведения рефакторинга, пользователю нужны всего два пакета: 
\family typewriter
\series bold
refactoring
\family default
\series default
, который содержит функции, проводящие рефакторинг, а также 
\family typewriter
\series bold
errors
\family default
\series default
, в котором объявлен тип 
\family typewriter
\series bold
GoRefactorError
\family default
\series default
.
 Значение этого типа возвращается любой функцией рефакторинга в случае ошибки.
 Для типа 
\family typewriter
\series bold
GoRefactorError
\family default
\series default
 объявлена функция 
\family typewriter
\series bold
String
\family default
\series default
, которая возвращает текстовое сообщение об ошибке.
\end_layout

\begin_layout Standard
Все пакеты библиотеки GoRefactor, включая вышеописанные, сохраняются в папке
 '$GO_HOME/pkg/refactoring/'.
 Чтобы импортировать определенный пакет библиотеки, в операторе импорта
 нужно указать его адрес относительно корневой директории дерева пакетов
 Go.
 Это директория '$GO_HOME/pkg/', поэтому импорт, например, пакета 
\family typewriter
\series bold
refactoring
\family default
\series default
 будет выглядеть вот так:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

import "refactoring/refactoring"
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Проведение рефакторинга
\end_layout

\begin_layout Standard
Библиотека GoRefactor предоставляет функции для проведения рефакторинга
 программ на языке Go.
 Функции работают лишь с программами, структура которых соответствует структуре
 проекта GoRefactor (см.
 подраздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Проект-GoRefactor"

\end_inset

).
\end_layout

\begin_layout Standard
Каждая из функций рефакторинга получает на вход адрес файла, в котором будет
 производиться запрашиваемый рефакторинг.
 По этому адресу локализуется корень проекта GoRefactor, и, в случае успеха,
 система приступает к рефакторингу.
\end_layout

\begin_layout Standard
Также, результатом любой функции является пара значений.
 Первое -- флаг успеха, имеет тип 
\family typewriter
\series bold
bool
\family default
\series default
.
 Второе -- ошибка, которая возникла в процессе рефакторинга, имеет тип 
\family typewriter
\series bold
*errors.GoRefactorError
\family default
\series default
.
 Если флаг успеха имеет значение 
\family typewriter
\series bold
true
\family default
\series default
, то значение ошибки равно 
\family typewriter
\series bold
nil
\family default
\series default
.
\end_layout

\begin_layout Standard
Рассмотрим подробнее функции рефакторинга, предоставляемые пакетом 
\family typewriter
\series bold
refactoring
\family default
\series default
 библиотеки GoRefactor.
 
\end_layout

\begin_layout Paragraph
Переименование
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

переименование
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
Rename
\family default
\series default
.
 Сигнатура функции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func Rename(filename string,
\end_layout

\begin_layout Plain Layout

			line     int,
\end_layout

\begin_layout Plain Layout

			column   int,
\end_layout

\begin_layout Plain Layout

			newName  string)
\end_layout

\begin_layout Plain Layout

			(ok bool, err *errors.GoRefactorError)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Функция 
\family typewriter
\series bold
Rename
\family default
\series default
 производит переименование сущности, одно из вхождений которой находится
 по координатам, заданным параметрами 
\family typewriter
\series bold
filename
\family default
\series default
,
\family typewriter
\series bold
 line
\family default
\series default
 и 
\family typewriter
\series bold
column
\family default
\series default
.
 Параметр 
\family typewriter
\series bold
newName
\family default
\series default
 задает новое имя для сущности.
\end_layout

\begin_layout Paragraph
Извлечение метода
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

извлечение метода
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
ExtractMethod
\family default
\series default
.
 Сигнатура функции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func ExtractMethod( filename        string,
\end_layout

\begin_layout Plain Layout

					lineStart       int, 
\end_layout

\begin_layout Plain Layout

					colStart        int,
\end_layout

\begin_layout Plain Layout

					lineEnd         int,
\end_layout

\begin_layout Plain Layout

					colEnd          int,
\end_layout

\begin_layout Plain Layout

					methodName      string,
\end_layout

\begin_layout Plain Layout

					recieverVarLine int,
\end_layout

\begin_layout Plain Layout

					recieverVarCol  int)
\end_layout

\begin_layout Plain Layout

					(bool, *errors.GoRefactorError)
\end_layout

\end_inset

Функция 
\family typewriter
\series bold
ExtractMethod
\family default
\series default
 извлекает фрагмент кода из файла по адресу 
\family typewriter
\series bold
filename
\family default
\series default
, начало которого находится по координатам 
\family typewriter
\series bold
lineStart
\family default
\series default
 и 
\family typewriter
\series bold
colStart
\family default
\series default
, а окончание -- по координатам 
\family typewriter
\series bold
lineEnd
\family default
\series default
 и 
\family typewriter
\series bold
colEnd
\family default
\series default
.
 Имя нового метода задается параметром 
\family typewriter
\series bold
methodName
\family default
\series default
.
 
\end_layout

\begin_layout Standard
Если один из параметров нового метода необходимо сделать его приемником,
 то его координаты указываются в параметрах 
\family typewriter
\series bold
recieverVarLine
\family default
\series default
 и 
\family typewriter
\series bold
recieverVarCol
\family default
\series default
.
 Если выделение приемника не требуется, то оба параметра должны быть меньше
 нуля.
\end_layout

\begin_layout Paragraph
Встраивание метода
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

встраивание метода
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
InlineMethod
\family default
\series default
.
 Ее сигнатура:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func InlineMethod(  filename  string,
\end_layout

\begin_layout Plain Layout

					lineStart int,
\end_layout

\begin_layout Plain Layout

					colStart  int,
\end_layout

\begin_layout Plain Layout

					lineEnd   int,
\end_layout

\begin_layout Plain Layout

					colEnd    int)
\end_layout

\begin_layout Plain Layout

					(bool, *errors.GoRefactorError) 
\end_layout

\end_inset

Функция 
\family typewriter
\series bold
InlineMethod
\family default
\series default
 встраивает вызов метода в файле по адресу 
\family typewriter
\series bold
filename
\family default
\series default
.
 Вызов метода задан координатами начала (пареметры 
\family typewriter
\series bold
lineStart
\family default
\series default
 и 
\family typewriter
\series bold
colStart
\family default
\series default
) и конца (пареметры 
\family typewriter
\series bold
lineEnd
\family default
\series default
 и 
\family typewriter
\series bold
colEnd
\family default
\series default
).
\end_layout

\begin_layout Paragraph
Реализация интерфейса
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

реализация интерфейса
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
ImplementInterface
\family default
\series default
.
 Эта функция имеет следующую сигнатуру:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func ImplementInterface(filename   string,
\end_layout

\begin_layout Plain Layout

						line       int,
\end_layout

\begin_layout Plain Layout

						column     int,
\end_layout

\begin_layout Plain Layout

						typeFile   string,
\end_layout

\begin_layout Plain Layout

						typeLine   int,
\end_layout

\begin_layout Plain Layout

						typeColumn int,
\end_layout

\begin_layout Plain Layout

						asPointer  bool) 
\end_layout

\begin_layout Plain Layout

						(bool, *errors.GoRefactorError)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Функция 
\family typewriter
\series bold
ImplementInterface
\family default
\series default
 реализует интерфейс, одно из вхождений которого заданно координатами 
\family typewriter
\series bold
filename
\family default
\series default
, 
\family typewriter
\series bold
line
\family default
\series default
 и 
\family typewriter
\series bold
column
\family default
\series default
, для типа, одно из вхождений которого задано координатами 
\family typewriter
\series bold
typeFile
\family default
\series default
, 
\family typewriter
\series bold
typeLine
\family default
\series default
 и 
\family typewriter
\series bold
typeColumn
\family default
\series default
.
\end_layout

\begin_layout Standard
Если требуется реализовать интерфейс для типа-указателя, то параметр 
\family typewriter
\series bold
asPointer
\family default
\series default
 должен быть равен 
\family typewriter
\series bold
true
\family default
\series default
.
\end_layout

\begin_layout Paragraph
Выделение интерфейса
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

выделение интерфейса
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
ExtractInterface
\family default
\series default
.
 Сигнатура функции:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func ExtractInterface(  filename      string, 
\end_layout

\begin_layout Plain Layout

						line          int,
\end_layout

\begin_layout Plain Layout

						column        int,
\end_layout

\begin_layout Plain Layout

						interfaceName string)
\end_layout

\begin_layout Plain Layout

						(bool, *errors.GoRefactorError)
\end_layout

\end_inset

Функция 
\family typewriter
\series bold
ExtractInterface
\family default
\series default
 выделяет интерфейс параметра функции, вхождение которого в сигнатуру этой
 функции задано координатами 
\family typewriter
\series bold
filename
\family default
\series default
, 
\family typewriter
\series bold
line
\family default
\series default
 и 
\family typewriter
\series bold
column
\family default
\series default
, и сохраняет этот интерфейс в файле 
\family typewriter
\series bold
filename
\family default
\series default
 под именеи 
\family typewriter
\series bold
interfaceName
\family default
\series default
.
\end_layout

\begin_layout Paragraph
Сортировка объявлений
\end_layout

\begin_layout Standard
Рефакторинг 
\begin_inset Quotes fld
\end_inset

сортировка объявлений
\begin_inset Quotes frd
\end_inset

 выполняется функцией 
\family typewriter
\series bold
Sort
\family default
\series default
.
 Функция имеет следующую сигнатуру:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

func Sort(  filename                 string,
\end_layout

\begin_layout Plain Layout

			groupMethodsByType       bool,
\end_layout

\begin_layout Plain Layout

			groupMethodsByVisibility bool, 
\end_layout

\begin_layout Plain Layout

			sortImports              bool,
\end_layout

\begin_layout Plain Layout

			order                    string)
\end_layout

\begin_layout Plain Layout

			(bool, *errors.GoRefactorError)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Функция 
\family typewriter
\series bold
Sort
\family default
\series default
 сортирует объявления в файле 
\family typewriter
\series bold
filename
\family default
\series default
.
 Объявления группируются по типу.
 Функция Sort различает пять типов объявлений: константы, переменные, типы
 данных, методы и функции.
 Группы располагаются в файле в соответствии с правилами, заданными строкой
 
\family typewriter
\series bold
order
\family default
\series default
.
 В пределах группы объявления сортируются по алфавиту.
\end_layout

\begin_layout Standard
Строка 
\family typewriter
\series bold
order
\family default
\series default
 задает порядок, в котором будут расположены группы объявлений одного типа.
 Каждой группе соответствует символ в строке 
\family typewriter
\series bold
order
\family default
\series default
.
 Всего таких символов пять: '
\family typewriter
\series bold
c
\family default
\series default
' -- константы, '
\family typewriter
\series bold
v
\family default
\series default
' -- переменные, '
\family typewriter
\series bold
t
\family default
\series default
' -- типы данных, '
\family typewriter
\series bold
m
\family default
\series default
' -- методы, '
\family typewriter
\series bold
f
\family default
\series default
' -- функции.
 Например, передача строки '
\family typewriter
\series bold
tcvmf
\family default
\series default
' в качастве параметра 
\family typewriter
\series bold
order
\family default
\series default
 означает, что группы объявлений в файле будут расположены в следующем порядке:
 типы данных, константы, переменные, методы и функции.
 
\end_layout

\begin_layout Standard
Строка 
\family typewriter
\series bold
order
\family default
\series default
 не обязательно должна содержать символы всех групп, и может вообще быть
 пустой.
 В таких случаях используется порядок сортировки по умолчанию: константы,
 переменные, типы данных, методы, функции.
 Если строка 
\family typewriter
\series bold
order
\family default
\series default
 неполная, то указанные в ней группы сортируются правилам строки 
\family typewriter
\series bold
order
\family default
\series default
, а остальные -- в порядке по умолчанию.
\end_layout

\begin_layout Standard
Также возможна настройка дополнительных параметров сортировки.
 
\end_layout

\begin_layout Standard
Если параметр 
\family typewriter
\series bold
groupMethodsByType
\family default
\series default
 равен 
\family typewriter
\series bold
true
\family default
\series default
, то методы будут дополнительно сгруппированы по типу приемника.
 
\end_layout

\begin_layout Standard
Если параметр 
\family typewriter
\series bold
groupMethodsByVisibility
\family default
\series default
 равен 
\family typewriter
\series bold
true
\family default
\series default
, то методы будут дополнительно сгруппированы по модификатору доступа.
 Параметры 
\family typewriter
\series bold
groupMethodsByType
\family default
\series default
 и 
\family typewriter
\series bold
groupMethodsByVisibility
\family default
\series default
 не могут одновременно равняться 
\family typewriter
\series bold
true
\family default
\series default
, то есть одновременна возможна лишь одна дополнительная группировка методов.
\end_layout

\begin_layout Standard
Если параметр 
\family typewriter
\series bold
sortImports
\family default
\series default
 равен 
\family typewriter
\series bold
true
\family default
\series default
, то будет произведена алфавитная сортировка операторов импорта, по имени
 импортируемого пакета.
\end_layout

\begin_layout Subsection
Руководство пользователя тестовой утилиты 
\begin_inset CommandInset label
LatexCommand label
name "sub:Руководство-тестовой-утилиты"

\end_inset


\end_layout

\begin_layout Standard
Для тестирования работоспособности библиотеки GoRefactor была разработана
 тестовая утилита goref.
 Она позволяет пользователю проводить рефакторинг проектов GoRefactor, передавая
 настройки через параметры командной строки.
\end_layout

\begin_layout Standard
Утилита goref автоматически устанавливается вместе с библиотекой GoRefactor.
 Она помещается в директорию '$GO_HOME/bin/'.
\end_layout

\begin_layout Standard
Перед проведением рефакторингов проект GoRefactor нужно соответствующим
 образом настроить (см.
 подраздел 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Проект-GoRefactor"

\end_inset

).
 Утилита goref может ощутимо упростить этот процесс.
 Для этого, в корневой директории будущего проекта GoRefactor нужно выполнить
 команду 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

goref init
\end_layout

\end_inset

Утилита создаст файл 
\family typewriter
\series bold
goref.cfg
\family default
\series default
, в котором будет пустая секция 
\begin_inset Quotes fld
\end_inset

.packages
\begin_inset Quotes frd
\end_inset

, а также стандартная секция 
\begin_inset Quotes fld
\end_inset

.specialPackages
\begin_inset Quotes frd
\end_inset

.
 Также будут созданы стандартные конфигурационные файлы пакетов 
\family typewriter
\series bold
syscall
\family default
\series default
, 
\family typewriter
\series bold
os
\family default
\series default
 и 
\family typewriter
\series bold
runtime
\family default
\series default
.
 После этого пользователю потребуется лишь заполнить секцию 
\begin_inset Quotes fld
\end_inset

.packages
\begin_inset Quotes frd
\end_inset

 файла 
\family typewriter
\series bold
goref.cfg
\family default
\series default
 и, по необходимости, добавить секцию 
\begin_inset Quotes fld
\end_inset

.externPackages
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
После настройки проекта, пользователь может приступить к проведению рефакторинга.
 С помощью тестовой утилиты goref можно выполнить рефакторинг через командную
 строку:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

goref код_рефакторинга {параметры}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Поддерживаются следующие коды рефакторинга: 
\family typewriter
\series bold
ren
\family default
\series default
 -- переименование сущности, 
\family typewriter
\series bold
exm
\family default
\series default
 -- извлечение метода, 
\family typewriter
\series bold
inm
\family default
\series default
 -- встраивание метода, 
\family typewriter
\series bold
imi
\family default
\series default
 -- реализация интерфейса, 
\family typewriter
\series bold
exi
\family default
\series default
 -- извлечение интерфейса, 
\family typewriter
\series bold
sort
\family default
\series default
 -- сортировка объявлений.
 
\end_layout

\begin_layout Standard
Параметры командной строки для каждого рефакторинга передаются как параметры
 соответствующего метода библиотеки GoRefactor.
 Параметры типа 
\family typewriter
\series bold
bool
\family default
\series default
 передаются в виде флагов.
 Например, следующая команда
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

goref sort -t -i /home/username/project/package1/file1.go ctvfm
\end_layout

\end_inset

выполняет сортировку объявлений в файле 
\family typewriter
\series bold
file1.go
\family default
\series default
 в порядке, заданном строкой '
\family typewriter
\series bold
ctvfm
\family default
\series default
', с допольнительной группировкой методов по типу приемника (флаг 
\family typewriter
\series bold
-t
\family default
\series default
).
 Также будут отсортированы операторы импорта (флаг 
\family typewriter
\series bold
-i
\family default
\series default
).
\end_layout

\begin_layout Standard
Команда
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left,numberstyle={\tiny},tabsize=4"
inline false
status open

\begin_layout Plain Layout

goref help
\end_layout

\end_inset

выводит полную документацию по всем командам утилиты goref, и их параметрам.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Заключение
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Заключение}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Список литературы}
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\labelwidthstring Список литературы
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Скоробогатов С.Ю.
 
\emph on
Лекции по курсу 
\begin_inset Quotes fld
\end_inset

Компиляторы
\begin_inset Quotes frd
\end_inset


\emph default
.
 -- 2009.
\end_layout

\begin_layout Bibliography
\labelwidthstring Список литературы
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

The Go Programming Language [Электронный ресурс].
 -- Режим доступа: http://golang.org/.
\end_layout

\end_body
\end_document
